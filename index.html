<!DOCTYPE html>
<!-- vim: set expandtab ts=2 sw=2 tw=80: -->
<html>
  <head>
    <title>Web Animations 1.0</title>
    <meta charset="utf-8">
    <script src="respec/respec.js" class="remove"></script>
    <script
      src="http://dev.w3.org/2009/dap/ReSpec.js/js/lang/sh_javascript.min.js"
      class="remove"></script>
    <script class="remove">
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use
        // ED.
        specStatus: "ED",

        // the specification's short name, as in
        // http://www.w3.org/TR/short-name/
        // shortName:            "web-anim",

        // if your specification has a subtitle that goes below the main
        // formal title, define it here
        // subtitle   :  "an excellent document",

        // if you wish the publication date to be other than today, set this
        // publishDate:  "2009-08-06",

        // if the specification's copyright date is a range of years, specify
        // the start date here:
        // copyrightStart: "2012"

        // if there is a previously published draft, uncomment this and set
        // its YYYY-MM-DD date and its maturity status
        // previousPublishDate: "1977-03-15",
        // previousMaturity: "WD",

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI:
        "https://dvcs.w3.org/hg/FXTF/raw-file/tip/web-anim/index.html",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // if you want to have extra CSS, append them to this list
        // it is recommended that the respec.css stylesheet be kept
        extraCSS: ["respec/respec.css",
                   "web-animations.css"],

        // Turning off inlineCSS for now since if extraCSS points to
        // a relative URL your testing from a file URL the XHR will fail.
        // Probably should turn this back on once this is hosted on a server
        // somewhere.
        inlineCSS: false,

        // editors, add as many as you like
        // only "name" is required
        editors:  [
            { name: "Brian Birtles", mailto: "bbirtles@mozilla.com",
              company: "Mozilla Japan", companyURL: "http://mozilla.jp/" },
            { name: "Shane Stephens", mailto: "shans@google.com",
              company: "Google, Inc", companyURL: "http://www.google.com/" },
            { name: "Rik Cabanier", mailto: "cabanier@adobe.com",
              company: "Adobe Systems", companyURL: "http://www.adobe.com/" },
            { name: "Alex Danilo", mailto: "adanilo@google.com",
              company: "Google, Inc", companyURL: "http://www.google.com/" },
            { name: "Dmitry Baranovskiy", mailto: "baranovs@adobe.com",
              company: "Adobe Systems", companyURL: "http://www.adobe.com/" },
            { name: "Tab Atkins", mailto: "jackalmage@gmail.com",
              company: "Google, Inc", companyURL: "http://www.google.com/" },
        ],

        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.

        //authors:  [
        //    { name: "Your Name", url: "http://example.org/",
        //      company: "Your Company", companyURL: "http://example.com/" },
        //],

        // XXX If we continue using ReSpec then we need to tweak it to support
        // multiple working groups. It includes updating the patent section
        // prose to say "groups" instead of "group" etc.
        // name of the WG
        wg: "CSS Working Group (part of the Style Activity) and the SVG " +
            "Working Group (part of the Graphics Activity)",

        // URI of the public WG page
        // wgURI: "http://www.w3.org/Graphics/fx/",

        // name (without the @w3c.org) of the public mailing to which comments
        // are due
        wgPublicList: "public-fx",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI
        // from a random document unless you know what you're doing. If in
        // doubt ask your friendly neighbourhood Team Contact.
        wgPatentURI:  "",

        noIDLSorting: true,
        noIDLIn: true
      };
    </script>
    <!--
      ReSpec.js wishlist:

      Add here any issues you find with ReSpec including missing features. It
      will help us decide if we should continue using it and work out what we
      need to fix.

      * Need ability to cross-reference members of interfaces (e.g. constants
        etc.)
      * Get rid of the description section next to parameters? It seems more
        natural to describe the parameters in the description of the method?
      * Allow making cross-references to specific methods and members.
      * Don't make unofficial drafts use the Creative Commons Attribution
        license.
      * Support NamedConstructors (including where the parameters use angle
        brackets like sequence<TimedTemplate>)
      * Support getter/setter/deleter/creator
    -->
  </head>
  <body>
    <section id='abstract'>
      This is the abstract for your specification.
    </section>

    <section class="informative">
      <h2>Introduction</h2>
      <p>
        Web Animations defines features for supporting animation and
        synchronization on the Web platform by means of a programming interface.
        This interface is intended to be used both directly to easily produce
        animations using script, as well as a foundation for other
        specifications whose behavior can be defined in terms of these features.
      </p>
      <section>
        <h3>Relationship to other specifications</h3>
        <p>
          CSS Transitions [[CSS3-TRANSITIONS]], CSS Animations 
          [[CSS3-ANIMATIONS]], and SVG [[SVG112]] all provide mechanisms that
          generate animated content on a web page.
          Although the three specifications provide similar functionality,
          the syntaxes are incompatible and the animations cannot be
          interchanged.
          Furthermore, the interfaces available for interacting with animations
          from script are largely general-purpose interfaces with few features
          tuned specifically to the creation and manipulation of animations.
        </p>
        <p>
          This specification proposes an abstract animations model that
          encompasses the abilities of both CSS and SVG, and additionally
          provides a programming interface to expose these features to script.
        </p>
        <p>
          This specification is accompanied by a CSS embedding specification,
          which describes how CSS features can be implemented in terms of Web 
          Animations primitives, and an SVG embedding specification, which
          describes how SVG features can be implemented in terms of Web
          Animations primitives.
        </p>
        <p>
          As a result, this specification does not directly alter the behavior
          of CSS Transitions, CSS Animations, or SVG.
          However, Web Animations is intended to replace the SMIL Animation
          [[SMIL-ANIMATION]] specification where it is currently used to define
          the behavior of SVG's animation features.
        </p>
        <p>
          This specification makes some additions to some interfaces defined in
          HTML5 [[HTML5]].
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>Web Animations overview</h2>
      <p>
        At a glance, Web Animations consists of two largely independent
        pieces, a <em>timing model</em> and an <em>animation model</em>.
        The role of these pieces is as follows:
      </p>
      <dl>
        <dt>Timing model</dt>
        <dd>
          Takes a moment in time and converts it to a proportional distance
          within a single iteration of an animation called the <em>time
          fraction</em>.
        </dd>
        <dt>Animation model</dt>
        <dd>
          Takes the <em>time fractions</em> produced by the timing model and
          converts them into a series of values to apply to the target
          properties and attributes.
        </dd>
      </dl>
      <p>
        Graphically, this flow can be represented as follows:
      </p>
      <div class="figure">
        <img src="img/timing-and-animation-models.svg" width="700">
      </div>
      <p class="caption">
        Overview of the operation of Web Animations.<br>
        The current time is input to the timing model which produces a time
        fraction.<br>
        This distance is used as input to the animation model which produces the
        values to apply.
      </p>
      <p>
        For example, consider an animation that:
      </p>
      <ul>
        <li>starts after 3 seconds,</li>
        <li>runs twice,</li>
        <li>takes 2 seconds every time, and</li>
        <li>changes the width of a rectangle from 50 pixels to 100 pixels.</li>
      </ul>
      <p>
        The first three points apply to the timing model.
        At a time of 6 seconds, it will calculate that the animation should be
        half-way through its second iteration and produces the result 0.5.
        The animation model then uses that information to calculate a width for
        the rectangle of 75.
      </p>
      <p>
        This specification begins with the timing model and then proceeds to the
        animation model.
      </p>
    </section>

    <section class="informative">
      <h2>The timing model at a glance</h2>
      <p>
        Two features characterise the Web Animations timing model: it is
        <em>stateless</em> and it is <em>hierarchical</em>.
      </p>
      <section>
        <h3>Stateless</h3>
        <p>
          The Web Animations timing model operates by taking an input time and
          producing an output time fraction.
          Since the output is based solely on the input time and is entirely
          independent of previous inputs, the model may be described as
          stateless.
          This gives the model the following properties:
        </p>
        <dl>
          <dt>Frame-rate independent</dt>
          <dd>
            Since the output is independent of previous inputs, the rate at
            which the model is sampled will not affect its progress.
            Provided the input times are proportional to the progress of
            real-world time, animations will progress at an identical rate
            regardless of the capabilities of the device running them.
          </dd>
          <dt>Direction agnostic</dt>
          <dd>
            Since the sequence of inputs is insignificant, the model is
            directionless.
            This means that the model can be sampled in reverse or even in
            a backwards and forwards pattern without requiring any specialized
            handling.
          </dd>
          <dt>Constant-time seeking</dt>
          <dd>
            Since each input is independent of the previous input, the
            processing required to perform a seek operation, even far into the
            future, is at least potentially constant.
          </dd>
        </dl>
        <p>
          There are two apparent exceptions to the stateless behavior of the
          timing model.
        </p>
        <p>
          Firstly, events are fired when, for example, one sample falls
          on the opposite side of an animation's interval boundary to the
          previous sample.
          This is certainly stative behavior.
          However, events should be considered as a layer added on top of the
          core timing model.
          In the case where no event listeners are registered, the model is
          stateless.
        </p>
        <p>
          The other exception to this stateless behavior is that a number of
          methods such as <code>pause</code> and <code>reverse</code> are
          defined in terms of the time at which they are called and are
          therefore stative.
          These methods are provided primarily for convenience and are not part
          of the core timing model but, like events, are layered on top.
        </p>
        <p>
          Finally, each time the model is sampled, it can be considered to
          establish a temporary state.
          While this temporary state affects the values returned from the API,
          it has no influence on the subsequent samples and hence does not
          conflict with the stateless qualities described above.
        </p>
      </section>
      <section>
        <h3>Hierarchical</h3>
        <p>
          The other characteristic feature of the Web Animations timing model is
          that time is inherited.
          In effect, time begins with real world time (a monotonically
          increasing time source) and cascades down a number of steps to each
          animation.
          At each step, time may be shifted backwards and forwards, scaled,
          reversed, paused, and repeated.
        </p>
        <p class="todo">
          Need diagram here.
        </p>
        <p>
          A consequence of this hierarchical arrangement is that complex
          animation arrangements can be reversed, schedule, accelerated and so
          on, as a whole since the manipulations applied to the parent cascade
          down to its descendants.
          Furthermore, since time has a common source, it is easy to synchronize
          otherwise independent animations.
        </p>
        <p>
          Despite this notion of inherited time, some features are implemented
          outside of the time hierarchy.
          In particular, synchronisation with HTML's media controllers (see <a
          href="#synchronizing-with-media" class="sectionRef"></a>) requires
          mirroring changes to pause state between items in different branches
          of the time hierarchy.
        </p>
        <p>
          The first step in this hierarchy is the animation timeline.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>The animation timeline</h2>
      <p>
        Each document contains a timeline to which animations may be added.
        These animations have an interval during which they are scheduled to
        animate.
      </p>
      <div class="figure">
        <img src="img/timeline.svg" width="600">
      </div>
      <p class="caption">
        At time <em>t</em> animations A and B are animating.
        Animation C has finished animating.
        Animation D has yet to begin and is not animating.
      </p>
      <p>
        The start time of the timeline is defined in <a
        href="#start-of-the-timeline" class="sectionRef"></a>.
      </p>
      </div>
    </section>

    <section>
      <h2>Animations in the timeline</h2>
      <p>
        Animations in the timeline are represented by <code>Anim</code> objects.
      </p>
      <section>
        <h3>The <code>Anim</code> interface</h3>
        <div class="todo">
          Need to support <code>NamedConstructor</code>s (or even just multiple
          ctors) in respec so we can document how the ctors below work.
        </div>
        <dl title="
[Constructor (Element? elem, Object? properties,
              AnimGroup? parentGroup, optional double startTime),
 NamedConstructor = LinkedAnim(Element? elem, AnimTemplate template,
                               AnimGroup? parentGroup,
                               optional double startTime),
 NamedConstructor = ClonedAnim(Element? elem, Anim cloneSource,
                               AnimGroup? parentGroup,
                               optional double startTime)]
                interface Anim : TimedItem" class="idl">
          <dt>attribute AnimFunc func</dt>
          <dd>
            <p>
              The animation function to apply (see <a href="#animation-values"
              class="sectionRef"></a>).
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised on setting if this object is linked to a template (i.e.
                <code>template</code> is not <code>null</code>).
              </dd>
            </dl>
          </dd>
          <dt>attribute AnimTemplate? template</dt>
          <dd>
            <p>
              For linked animations (see <a href="#animation-templates"
              class="sectionRef"></a>), the <a>AnimTemplate</a> object
              from which this object derives its values.
              For animations that are not linked to a template, this property is
              <code>null</code>.
            </p>
            <p>
              Setting this property has the following effect:
            </p>
            <ol>
              <li>Let <var>new template</var> be the value to assign to the
                  <code>template</code> property.</li>
              <li>If <var>new template</var> is <code>null</code>,
                <ol>
                  <li>Call <code>unlink()</code>.</li>
                </ol>
              </li>
              <li>Otherwise,
                <ol>
                  <li>Set <code>timing</code> to <code><var>new
                      template</var>.timing.clone()</code>.</li>
                  <li>Set <code>func</code> to <code><var>new
                      template</var>.func.clone()</code>.</li>
                  <li>Set <code>template</code> to <code><var>new
                      template</var></code>.</li>
                </ol>
              </li>
            </ol>
          </dd>
          <dt>readonly attribute Element? targetElement</dt>
          <dd>
            <p>
              The element being animated by this object.
              This may be <code>null</code> for animations that do not target
              a <code>Element</code> such as an animation that produces a sound
              using an audio API.
            </p>
          </dd>
          <dt>AnimTemplate templatize()</dt>
          <dd>
            <p>
              If this object is not already linked to a template,
              creates a new <a>AnimTemplate</a> object based on this object and
              links this object to it (see <a href="#animation-templates"
              class="sectionRef"></a>).
            </p>
            <p class="feedbackWanted">
              What is the more useful behavior? To always create a template?
              Or to only create one if it doesn't already have one?
            </p>
            <p>
              The effect is equivalent to the following steps:
            </p>
            <ol>
              <li>Let <var>source</var> be the object on which
                  <code>templatize</code> is called.</li>
              <li>If <code><var>source</var>.template</code> is not
                  <code>null</code>, return.</li>
              <li>Create a new <a>AnimTemplate</a> object,
                  <var>template</var>.</li>
              <li>Set <code><var>template</var>.timing</code> to
                  <code><var>source</var>.timing.clone()</code>.</li>
              <li>Set <code><var>template</var>.func</code> to
                  <code><var>source</var>.func.clone()</code>.</li>
              <li>Set <code><var>source</var>.template</code> to
                  <var>template</var>.</li>
              <li>Return <var>template</var>.</li>
            </ol>
          </dd>
          <dt>AnimTemplate? unlink()</dt>
          <dd>
            <p>
              Makes this animation independent of the template with which it is
              associated if any
              (see <a href="#animation-templates" class="sectionRef"></a>)
            </p>
            <p>
              After setting <code>template</code> to <code>null</code> the
              previous value of <code>template</code> is returned.
            </p>
            <p>
              The effect is equivalent to the following steps:
            </p>
            <ol>
              <li>If <code>template</code> is <code>null</code>, return
                  <code>null</code>.</li>
              <li>Let <var>old template</var> be <code>template</code>.</li>
              <li>Set <code>timing</code> to
                  <code>template.timing.clone()</code>.</li>
              <li>Set <code>func</code> to
                  <code>template.func.clone()</code>.</li>
              <li>Set <code>template</code> to <code>null</code> (but do not
                  recursively call this function).</li>
              <li>Return <var>old template</var>.</li>
            </ol>
          </dd>
        </dl>
        <section class="informative">
          <h4>Using anonymous parameter objects</h4>
          <p>
            For convenience, the <a>Anim</a> constructor allows passing in
            a collection of parameters on an anonymous object that are then
            assigned to the appropriate sub-properties of the newly
            construction <a>Anim</a> object.
          </p>
          <p>
            This allows the following usage:
          </p>
          <pre class='example sh_javascript'>
var anim = new Anim(elem, { duration: 3, prop: 'height', to: '30px' });
          </pre>
          <p>
            When using a collection of parameters, the timing parameters may
            be specified by using either of the following methods:
          </p>
          <ul>
            <li>
              <p>Setting a <code>timing</code> property on the parameters
                 object to a <a>Timing</a> object. For example,</p>
              <p><pre class="sh_javascript"><code>{
  timing: otherAnim.timing.clone()
}</code></pre>
              </p>
              <p>
                This object is directly assigned to the new <a>Anim</a>
                object's <code>timing</code> property, it is not copied.
              </p>
            </li>
            <li>
              <p>Setting the timing properties individually on the parameters
                 object itself. For example,</p>
              <p><pre class="sh_javascript"><code>{
  duration: 3,
  startDelay: 0.5
}</code></pre>
              </p>
              <p>
                The property names on the parameters object are matched with
                those defined on the <a>Timing</a> interface.
                Unspecified properties take on their default values.
              </p>
            </li>
          </ul>
          <p>
            If the <code>timing</code> property is set, all other timing
            properties are ignored.
          </p>
          <p class="feedbackWanted">
            This is because the <code>timing</code> property is shared in this
            case.
            If we allow both to be used (i.e. <code>timing</code> property
            plus some overrides), you would end up affecting other users of
            the same <a>Timing</a> object which is probably unexpected.
            If we decide to make it copy the <a>Timing</a> object before
            assigning, then allowing both methods to be used together is safe
            and probably very convenient.
          </p>
          <p>
            Within the collection of parameters, the animation parameters may
            be specified by using either of the following methods:
          </p>
          <ul>
            <li>
              <p>Setting a <code>func</code> property on the parameters
                 object to an <a>AnimFunc</a> object. For example,</p>
              <p><pre class="sh_javascript"><code>{
  func: otherAnim.func.clone()
}</code></pre>
              </p>
              <p>
                This object is directly assigned to the new <a>Anim</a>
                object's <code>func</code> property, it is not copied.
              </p>
             </li>
            <li>
              <p>Setting a <code>prop</code> property on the parameters object
                 specifying the property on the target element to animate,
                 along with a <code>to</code> property giving the target
                 value and an optional <code>from</code> property giving the
                 starting value. For example,</p>
              <p><pre class="sh_javascript"><code>{
  prop: 'height',
  from: '100px', // 'from' is optional
  to: '200px'
}</code></pre>
              </p>
              <p>
                These values are used to build a new
                <a>KeyframesAnimFunc</a> object.
              </p>
              <div class="feedbackWanted">
                <p>
                  I think it would be better to follow what Raphael does here:
                </p>
                <p><pre class="sh_javascript"><code>{
  'height': '200px',
}</code></pre>
                <p>
                  There are two issues here:
                </p>
                <ol>
                  <li>Not possible to do from-to animations with this
                      arrangement. &rarr; That's fine so long as the ctor for
                      <a>KeyframesAnimFunc</a> is easy to use.</li>
                  <li>Potential clashes between attribute/property names and
                      any property defined on the <a>Timing</a> interface.
                      &rarr; Maybe we just nip this in the bud and append
                      something on to the property name, e.g.
                      <code>prop:height</code>.</li>
                </ol>
              </div>
          </ul>
          <p>
            If the <code>func</code> property is set, any
            <code>prop</code>, <code>from</code>, or <code>to</code>
            properties are ignored.
          </p>
        </section>
        <section>
          <h4>Interpreting property collections</h4>
          <p>
            The interpretation of these parameters is based on the following
            process:
          </p>
          <ol>
            <li>Let <var>params</var> be the passed in object whose properties
                represent the parameters to set.</li>
            <li>Construct a new <a>Anim</a> object, <var>anim</var>.</li>
            <li>
              <p>
                Set the timing properties using the first matching condition
                from the following list.
              </p>
              <dl class="switch">
                <dt>If <code><var>params</var>.timing</code> is set,</dt>
                <dd>
                  Set <code><var>anim</var>.timing</code> to
                      <code><var>params</var>.timing</code>.
                </dd>
                <dt>Otherwise (including if <var>params</var> is
                    <code>null</code>),</dt>
                <dd>
                  <ol>
                    <li>Initialize <code><var>anim</var>.timing</code> property
                        to a newly constructed <code>Timing</code> object using
                        the default values for each property.</li>
                    <li>If <var>params</var> is not <code>null</code>,
                        then for each of property, <var>candidate</var>, of
                        <var>params</var>, if
                        <code><var>anim</var>.timing.<var>candidate</var></code>
                        exists, set
                        <code><var>anim</var>.timing.<var>candidate</var></code>
                        to
                        <code><var>params</var>.<var>candidate</var></code>.
                        <p class="todo">
                          <code>TimingFunc</code> will probably need
                          special handling. Do we copy it? Will we need to
                          translate strings (e.g. "ease-in") into numbers, or
                          will <code>TimingFunc</code> have
                          a ctor/property that takes care of this?
                        </p>
                        <p class="todo">
                          Setting a property to an invalid value will sometimes
                          raise an exception aborting the whole process.
                          In some cases that's what you want but in terms of
                          forwards compability, it would be nice to be able to
                          set a value in a way that older UAs that don't support
                          the new value would just ignore it (like usual
                          HTML/CSS processing).
                          e.g. <code>'@dur': '50%'</code> means, "Set the
                          'dur' property but if there's any exception, just
                          ignore it".
                        </p>
                        <p class="todo">
                          Do we want to provide a facility to convert
                          <code>'50ms'</code> to <code>0.05</code>?
                          Or can we define this on the <a>Timing</a> interface
                          somehow?
                        </p>
                        <p class="todo">
                          Similarly, should we allow property aliases
                          to match up with CSS/SVG syntax, e.g.
                          <code>duration</code> is interpreted as
                          <code>duration</code>?
                        </p>
                    </li>
                  </ol>
                </dd>
            </li>
            <li>
              <p>
                Initialize the animation function based on the first matching
                condition from the following,
              </p>
              <dl class="switch">
                <dt>If <code><var>params</var>.func</code> is set,</dt>
                <dd>
                  Set <code><var>anim</var>.func</code> to
                      <code><var>params</var>.func</code>.
                </dd>
                <dt>If <code><var>params</var>.prop</code>
                    and <code><var>params</var>.to</code> is set,</dt>
                <dd>
                  <ol>
                    <li>Create a new <a>KeyframesAnimFunc</a>,
                        <var>func</var>.</li>
                    <li>Set <code><var>func</var>.property</code> to
                        <code><var>params</var>.prop</code>.</li>
                    <li>If <code><var>params</var>.from</code> is set,
                      <ol>
                        <li>Create a new <a>AnimFrame</a>, <var>first
                            frame</var>.</li>
                        <li>Set <code><var>first frame</var>.value</code> to
                                <code><var>params</var>.from</code>.</li>
                        <li>Set <code><var>first frame</var>.offset</code> to
                            0.</li>
                        <li>Call
                <code><var>func</var>.frames.add(<var>first frame</var>)</code>.
                        </li>
                      </ol>
                    </li>
                    <li>Create a new <a>AnimFrame</a>, <var>last
                        frame</var>.</li>
                    <li>Set <code><var>last frame</var>.value</code> to
                            <code><var>params</var>.to</code>.</li>
                    <li>Set <code><var>last frame</var>.offset</code> to 1.</li>
                    <li>Call
                <code><var>func</var>.frames.add(<var>last frame</var>)</code>.
                    </li>
                    <li>Set <code><var>anim</var>.func</code> to
                        <var>func</var>.</li>
                  </ol>
                </dd>
                <dt>Otherwise (including if <var>params</var> is
                    <code>null</code>),</dt>
                <dd>
                  <p>
                    Set <code><var>anim</var>.func</code> to a newly
                    constructed empty <a>KeyframesAnimFunc</a>.
                  </p>
                  <p class="todo">
                    Can you even create an empty one without setting a property?
                  </p>
                </dd>
              </dl>
            </li>
            <li>
              Return <var>anim</var>.
            </li>
          </ol>
        </section>
      </section>
    </section>

    <section>
      <h2>Timing animations</h2>
      <section class="informative">
        <h3>Animation intervals</h3>
        <section>
          <h4>Scheduling an animation: The item interval</h4>
          <p>
            Each animation in the timeline has a time where it is defined to
            begin called the <dfn>start time</dfn>.
            The span of time from the <var>start time</var> until the animation
            completes animating is called the <dfn>item interval</dfn>.
            Each animation has only one item interval as illustrated below.
          </p>
          <div class="figure">
            <img src="img/item-interval.svg" width="600">
          </div>
          <p class="caption">
            The <a>item interval</a> of an animation begins at the animation's
            <a>start time</a> and ends when the animation completes.
          </p>
        </section>
        <section>
          <h4>Delaying an animation: The animation interval</h4>
          <p>
            It is possible to define an animation so that it begins at some
            offset from its <a>start time</a> using a <dfn>start delay</dfn>.
            As a result, the actual period of time that an animation is
            animating may not match the <a>item interval</a>.
            By taking the <a>start delay</a> into account we can define the
            <dfn>animation interval</dfn> as the period of time that an
            animation is actually animating.
            Like the <a>item interval</a>, each animation has only one
            <a>animation interval</a>.
          </p>
          <p>
            The relationship between the <a>item interval</a> and <a>animation
            interval</a> is illustrated below.
          </p>
          <div class="figure">
            <img src="img/item-and-animation-intervals.svg" width="600">
          </div>
          <p class="caption">
            Examples of the effect of the start delay on endpoints of the
            item interval and animation interval.<br>
            (a) An animation with no delay; the item interval and animation
            interval are identical.<br>
            (b) An animation with a positive delay; the animation interval
            starts after the item interval but they end together.<br>
            (c) An animation with a negative delay; the animation interval
            starts before the item interval but, again, they end together.
          </p>
          <p>
            The <a>item interval</a> is the primary frame of reference for
            scheduling.
            For example, <a
            href="#the-start-time-of-children-of-a-sequence-animation-group">sequencing</a>
            is defined in terms of the item interval.
            Likewise, actions such as <a href="#seeking-a-timed-item">seeking
            an animation</a> are based around the item interval and not the
            animation interval.</a>
          </p>
          <p class="note">
            Note that it is possible to define a <a>start delay</a> such that
            the animation ends before the <a>start time</a>.
            In this case the <a>item interval</a> starts and ends at the
            <a>start time</a>, it does not stretch backwards to the actual end
            of the <a>animation interval</a>.
          </p>
        </section>
        <section>
          <h4>Repeating an animation: the iteration interval</h4>
          <p>
            It is possible to specify that an animation's effect should repeat
            a fixed number of times or even indefinitely.
            This repetition occurs <em>within</em> the <a>animation
            interval</a>.
            The span of time during which a single repetition takes place is
            called an <dfn>iteration interval</dfn>.
          </p>
          <p>
            Unlike the <a>item interval</a> and <a>animation interval</a>, an
            animation can have multiple <a>iteration interval</a>s although
            typically only the interval corresponding to the <a>current
            iteration</a> is of interest.
          </p>
          <p>
            The relationship between the <a>item interval</a>, <a>animation
            interval</a> and <a>iteration interval</a> is illustrated below.
          </p>
          <div class="figure">
            <img src="img/iteration-intervals.svg" width="700">
          </div>
          <p class="caption">
            For an animation that is specified to repeat 2.5 times, three
            iteration intervals are created although the final interval is
            cut-off by the animation interval.
          </p>
          <p>
            Based on the distinction between the animation interval and
            iteration itervals, we can also define the <dfn>animation
            duration</dfn> and <dfn>iteration duration</dfn> as follows:
          </p>
          <dl>
            <dt>Iteration duration</dt>
            <dd>
              The time taken for a single iteration of the item to complete.
            </dd>
            <dt>Animation duration</dt>
            <dd>
              The time taken for the entire animation effect to complete,
              including repetitions.
              This may be longer or shorter than the iteration duration.
            </dd>
          </dl>
        </section>
        <section>
          <h4>Summary of animation intervals</h4>
          <p>
            In summary, for a given animation, we can describe the following
            intervals:
          </p>
          <dl>
            <dt>Item interval</dt>
            <dd>
              The time from an animation's <a>start time</a> until the animation
              finishes to play, that is, the end of the <a>animation
              interval</a>.
            </dd>
            <dt>Animation interval</dt>
            <dd>
              The span of time that an animation is actually playing.
              The interval begins at the animation's <a>start time</a> plus any
              <a>start delay</a> defined on the animation, and ends when the
              animation finishes to play as determined by the <a>animation
              duration</a>.
            </dd>
            <dt>Iteration interval</dt>
            <dd>
              The span of time during which a single iteration of the
              animation effect takes place.
            </dd>
          </dl>
        </section>
      </section>
      <section class="informative">
        <h3>Animation fill behavior</h3>
        <p>
          Outside of the <a>animation interval</a>, an animation may still
          affect its target depending on its <dfn>fill mode</dfn>.
          The different modes are as follows:
        </p>
        <dl>
          <dt>none</dt>
          <dd>
            The animation does not affect its target outside of the
            <a>animation interval</a>.
          </dd>
          <dt>forwards</dt>
          <dd>
            For times that occur later than the <a>animation interval</a>, the
            animation will continue to apply to its target the
            animation value that was used at the end of the <a>animation
            interval</a>.

            For times that occur before the <a>animation interval</a>, the
            animation will not affect its target.
          </dd>
          <dt>backwards</dt>
          <dd>
            For times that occur before the <a>animation interval</a>, the
            animation will apply the same animation value that will be used at
            the start of the <a>animation interval</a>.

            For times that occur later than the <a>animation interval</a>, the
            animation will not affect its target.
          </dd>
          <dt>both</dt>
          <dd>
            For times that occur before the <a>animation interval</a>, the
            backwards fill behavior is used.

            For times that occur after the <a>animation interval</a>, the
            forwards fill behavior is used.
          </dd>
        </dl>
        <p>
          Some examples of the these fill modes are illustrated below.
        </p>
        <div class="figure">
          <img src="img/animation-state-and-fill-behavior.svg" width="600">
        </div>
        <p class="caption">
          Examples of various fill modes and the animation states produced.<br>
          (a) fill mode &lsquo;none&rsquo;. The animation has no effect outside
              its animation interval.<br>
          (b) fill mode &lsquo;forwards&rsquo;. After the animation interval has
              finished, the animation continues to apply a fill value to the
              target.<br>
          (c) fill mode &lsquo;backwards&rsquo;. The animation applies a fill
              value to its target until the start of the animation
              interval.<br>
          (d) fill mode &lsquo;both&rsquo;. Both before and after the animation
              interval the animation applies a fill value to its target.
        </p> 
        <p>
          At a given time, it is possible to describe an animation as <dfn>in
          effect</dfn> if either (a) the time falls within the animation's
          <a>animation interval</a>, or (b) the fill mode of the animation
          causes it to apply a fill mode to its target at the given time.
        </p>
        <p>
          The normative definition of fill behavior is incorporated in the
          calculation of the animation time in <a
          href="#calculating-the-animation-time" class="sectionRef"></a>.
        </p>
        <p class="note">
          Note that setting a fill mode has no bearing on the endpoints of the
          <a href="#animation-intervals">animation intervals</a> including the
          <a>item time</a>.
          However, the fill mode <em>does</em> have an effect on the
          calculation of the <a>animation time</a> and consequently the
          <a>iteration time</a> since these are defined only when the animation
          is <a>in effect</a>.
        </p>
      </section>
      <section class="informative">
        <h3>Time spaces</h3>
        <p>
          Times in Web Animations are relative to some point of reference. These
          different points of reference produce different time spaces.
        </p>
        <p>
          This can be compared to coordinate spaces as used in computer
          graphics.
          The zero time of a time space is analogous to the origin of
          a coordinate space.
        </p>
        <p>
          Within Web Animations, some of the common time spaces are:
        </p>
        <dl>
          <dt><dfn>Document time space</dfn></dt>
          <dd>
            A time space whose zero time is the start time of the document
            timeline as defined in <a href="#start-of-the-timeline"
            class="sectionRef"></a>.
          </dd>
          <dt><dfn>Item time space</dfn></dt>
          <dd>
            A time space whose zero time is the start of the animation's <a>item
            interval</a>, that is, the <a>start time</a>.
          </dd>
          <dt><dfn>Animation time space</dfn></dt>
          <dd>
            A time space whose zero time is the beginning of a timed item's
            <a>animation interval</a>.
          </dd>
          <dt><dfn>Iteration time space</dfn></dt>
          <dd>
            A time space whose zero time is the beginning of the <a>current
            iteration</a>.
          </dd>
        </dl>
        <p>
          In addition to these time spaces, when animation groups are used (see
          <a href="#grouping-and-synchronization" class="sectionRef"></a>) we
          can talk about the <dfn>parent iteration time space</dfn>.
          The zero time of <em>parent iteration time space</em> is the beginning
          of the parent animation group's <a>current iteration</a>.
          When animation groups are not used, this is equivalent to <a>document
          time space</a>.
        </p>
        <p>
          Some of these time spaces are illustrated below.
        </p>
        <div class="figure">
          <img src="img/time-spaces.svg" width="600">
        </div>
        <p class="caption">
          A comparison of item time, animation time, and iteration time for an
          animation with a iteration duration of 1s and an iteration count of
          2.5.
        </p>
        <p class="note">
          Note that while the time spaces themselves are not bounded, Web
          Animations defines <var>animation time</var> and <var>iteration
          time</var> such that they are clamped to a set range as shown in the
          diagram.
          For example, whilst a time of -1 second is a valid time in
          <em>animation time space</em>, the procedure for calculating the
          <var>animation time</var> defined in <a
          href="#calculating-the-animation-time" class="sectionRef"></a> will
          never return a negative value.
        </p>
      </section>
      <section class="informative">
        <h3>Interval timing</h3>
        <p>
          For intervals of time, Web Animations uses an endpoint-exclusive
          timing model. This means that whilst the begin time of an interval
          is included in the interval, the end time time is not. In interval
          notation this can written <code>[begin,end)</code>. This model
          provides sensible behavior when intervals are repeated and sequenced
          since there is no overlap between the intervals.
        </p>
        <p>
          In the examples below, for the repeated animation, at animation time
          1s, the iteration time is 0.
          For the sequenced animation, in the absence of any fill mode,
          at parent iteration time 1s, only animation B can affect its target;
          there is no overlap.
        </p>
        <div class="figure">
          <img src="img/endpoint-exclusive-timing.svg" width="600">
        </div>
        <p class="caption">
          Illustration of end-point exclusive timing. For both repeated and
          sequenced animations there is no overlap at the boundaries between
          intervals.
        </p>
        <p>
          An exception to this behavior is that when performing a fill, if
          the fill begins at an interval endpoint, the endpoint is used. This
          behavior falls out of the algorithm given in <a
          href="#calculating-the-unscaled-iteration-time"
          class="sectionRef"></a> and is illustrated below.
        </p>
        <div class="figure">
          <img src="img/endpoint-exclusive-timing-and-fill.svg" width="700">
        </div>
        <p class="caption">
          After one iteration, the first frame of the animation is shown, but
          after two iterations (and thereonwards), the last frame is shown due
          to the special behavior defined when an animation fills.
        </p>
      </section>
      <section>
        <h3>Specifying timing properties</h3>
        <p>
          Timing properties are collected under the <code>Timing</code>
          interface.
          All properties have a default value associated with them which is the
          value used when a new <code>Timing</code> object is constructed.
        </p>
        <p>
          If this object is attached to a linked <a>Anim</a> or <a>AnimGroup</a>
          (see <a href="#animation-templates" class="sectionRef"></a>) then it
          is readonly and attempting to set any of its properties will result in
          a DOMException of type <code>NoModificationAllowedError</code> being
          thrown.
          In order to modify the properties of a readonly object, it is
          necessary to first call the <code>unlink</code> method on the
          corresponding <a>Anim</a> or <a>AnimGroup</a> object.
        </p>
        <p>
          When throwing a DOMException as a result of attempting to set
          a readonly property, <a>user agent</a>s that provide debugging
          feedback SHOULD also provide feedback indicating the reason that this
          object is readonly and the remedy described above.
        </p>
        <section>
          <h4>The <code>Timing</code> interface</h4>
          <dl title="interface Timing" class="idl">
            <dt>attribute double startDelay</dt>
            <dd>
              <p>
                The number of seconds which, when added to the timed item's
                <code>startTime</code>, defines the lower bound of the timed
                item's <a>animation interval</a>.
              </p>
              <p>
                A non-normative description of the effect of this property on
                timing is given in <a
                href="#delaying-an-animation--the-animation-interval"
                class="sectionRef"></a>.
              </p>
              <p>
                The <var>default value</var> is 0.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>attribute unrestricted double? duration</dt>
            <dd>
              <p>
                The duration specified for a single iteration.
                This may be <code>null</code> in which case the intrinsic
                duration will be used.
                If set, it must be greater than or equal to zero (including
                positive infinity).
              </p>
              <p>
                This property corresponds to the <a>iteration duration</a>
                described in <a
                href="#repeating-an-animation--the-iteration-interval"
                class="sectionRef"></a>.
              </p>
              <p>
                The <var>default value</var> is <code>null</code>.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if the value to set is a real number less
                  than zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute unrestricted double iterationCount</dt>
            <dd>
              <p>
                A real number greater than or equal to zero (including positive
                infinity) representing the number of times to repeat the
                animation.
              </p>
              <p>
                The <var>default value</var> is 1.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if the value to set is a real number less
                  than zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute double iterationStart</dt>
            <dd>
              <p>
                A finite real number greater than or equal to zero representing
                the number of iterations into the animation at which to begin.
                For example, a value of 0.5 would cause the animation to begin
                half-way through the first iteration.
                If this value is greater than <code>iterationCount</code> then
                it is effectively clamped as defined in the definition of
                <a>iteration start</a>.
              </p>
              <p>
                The <var>default value</var> is 0.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
                <dt>DOMException of type <code>IndexSizeError</code></dt>
                <dd>
                  Raised on setting if the value to set is a real number less
                  than zero.
                </dd>
              </dl>
            </dd>
            <dt>attribute double playbackRate</dt>
            <dd>
              <p>
                A real number that acts as a multiplier on the item's rate of
                play.
                For example, a value of 2.0 will cause the item to run at twice
                its usual speed.
                A value of -1.0 will cause the item to play backwards.
                The <code>playbackRate</code> is applied to the item's
                <a>animation time</a> and hence has no effect on the <a>start
                time</a> (see <a href="#time-spaces" class="sectionRef"></a>).
              </p>
              <p>
                Setting this attribute will affect the item's intrinsic
                animation duration as described in <a
                href="#calculating-the-intrinsic-animation-duration"
                class="sectionRef"></a>.
              </p>
              <p>
                The <var>default value</var> is 1.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>attribute PlaybackDirection direction</dt>
            <dd>
              <p>
                Direction behavior as specified by one of the
                <a>PlaybackDirection</a> enumeration values.
              </p>
              <p>
                The <var>default value</var> is <code>"normal"</code>.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>attribute TimingFunc timingFunc</dt>
            <dd class="todo">
              TBD.
            </dd>
            <dt>attribute FillMode fill</dt>
            <dd>
              <p>
                Fill mode as specified by one of the <a>FillMode</a> enumeration
                values.
              </p>
              <p>
                The <var>default value</var> is <code>"none"</code>.
              </p>
              <p>
                Exceptions:
              </p>
              <dl class="exceptions">
                <dt>DOMException of type
                    <code>NoModificationAllowedError</code></dt>
                <dd>
                  Raised on setting if this object is readonly.
                </dd>
              </dl>
            </dd>
            <dt>Timing clone ()</dt>
            <dd>
              <p>
                Creates a new <a>Timing</a> object with each of its properties
                set to the same value as this object with the exception of the
                <code>timingFunc</code> property which is set to
                <code>timingFunc.clone()</code>.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h4>The <code>FillMode</code> enumeration</h4>
          <p>A non-normative description of these modes is given in
             <a href="#animation-fill-behavior" class="sectionRef"></a>.</p>
          <dl title="enum FillMode" class="idl">
            <dt>none</dt>
            <dd>
              No fill.
            </dd>
            <dt>forwards</dt>
            <dd>
              Fill forwards.
            </dd>
            <dt>backwards</dt>
            <dd>
              Fill backwards.
            </dd>
            <dt>both</dt>
            <dd>
              Fill backwards and forwards.
            </dd>
          </dl>
        </section>
        <section>
          <h4>The <code>PlaybackDirection</code> enumeration</h4>
          <dl title="enum PlaybackDirection" class="idl">
            <dt>normal</dt>
            <dd>
              All iterations are played as specified.
            </dd>
            <dt>reverse</dt>
            <dd>
              All iterations are played in the reverse direction from the way
              they are specified.
            </dd>
            <dt>alternate</dt>
            <dd>
              Even iterations are played as specified, odd iterations are played
              in the reverse direction from the way they are specified.
            </dd>
            <dt>alternate-reverse</dt>
            <dd>
              Even iterations are played in the reverse direction from the way
              they are specified, odd iterations are played as specified.
            </dd>
          </dl>
        </section>
      </section>
      <section>
        <h3>The <code>TimedItem</code> interface</h3>
        <p>
          The application of the timing properties specified in
          a <code>Timing</code> object to an actor in the animation timeline
          is represented by the <code>TimedItem</code> interface.
        </p>
        <dl title="interface TimedItem" class="idl">
          <dt>readonly attribute Timing timing</dt>
          <dd>
            <p>
              The timing parameters for this item.
            </p>
            <p class="todo">
              Make this writeable.
            </p>
          </dd>
          <dt>attribute double? totalTime</dt>
          <dd>
            <p>
              Returns the <a>item time</a> of this item in seconds.
            </p>
            <p>
              Setting this value performs a seek operation according to the
              steps described in described in <a href="#seeking-a-timed-item"
              class="sectionRef"></a>.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>InvalidStateError</code></dt>
              <dd>
                Raised on setting if <code>parentGroup</code> is a sequence
                animation group (see <a
                href="#the-start-time-of-children-of-a-sequence-animation-group"
                class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>attribute unrestricted double totalDuration</dt>
          <dd>
            <p>
              The length in seconds of the <a>item interval</a>.
            </p>
            <p>
              Initially, this attribute will reflect the sum of the <a>intrinsic
              animation duration</a> plus <code>timing.startDelay</code>.
              Changes to the model that cause the <a>intrinsic animation
              duration</a> to change are reflected in the value returned here.
            </p>
            <p>
              The calculated value may be be overridden by setting this
              attribute to any real number.
              Negative values are clamped to zero.
              Setting this attribute to <code>undefined</code> has the effect of
              clearing the override value so that the attribute returns to
              reflecting the sum of <a>intrinsic animation duration</a> and
              <code>timing.startDelay</code>.
            </p>
          </dd>
          <dt>readonly attribute double? currentTime</dt>
          <dd>
            The time in seconds representing the offset into the iteration
            duration using the steps described in <a
            href="#calculating-the-iteration-time" class="sectionRef"></a>.
            As a result of that definition, this property will be
            non-<code>null</code> if and only if the animation is in
            <a>in effect</a>.
          </dd>
          <dt>readonly attribute unsigned long? currentIteration</dt>
          <dd>
            The number of iterations that have completed as described in <a
              href="#calculating-the-current-iteration" class="sectionRef"></a>.
          </dd>
          <dt>readonly attribute unrestricted double duration</dt>
          <dd>
            The iteration duration calculated for this item.
            If <code>timing.duration</code> is set and greater than or
            equal to zero, this will match <code>timing.duration</code>.
            Otherwise, this will reflect the calculated intrinsic duration of
            the item as described in <a
            href="#calculating-the-iteration-duration" class="sectionRef"></a>.
          </dd>
          <dt>attribute double startTime</dt>
          <dd>
            <p>
              The time which when combined with the
              <code>timing.startDelay</code> defines the lower bound of the
              <a>animation interval</a>.
              It is expressed in seconds in the iteration time space of
              <code>parentGroup</code>.
            </p>
            <p>
              When the parent animation group is a sequence group, any
              previously set value set for <code>startTime</code> is ignored and
              instead the value of this property is determined by the procedure
              defined in <a
              href="#the-start-time-of-children-of-a-sequence-animation-group"
              class="sectionRef"></a>.
              Furthermore, attempts to set this property will raise an
              DOMException of type <code>InvalidStateError</code>.
              If this item is later made the child of a parallel animation
              group, any previously set value will be restored.
            </p>
            <p>
              The <code>start</code> method can be used to set this property
              relative to the current time.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>InvalidStateError</code></dt>
              <dd>
                Raised on setting if <code>parentGroup</code> is a sequence
                animation group (see <a
                href="#the-start-time-of-children-of-a-sequence-animation-group"
                class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>readonly attribute unrestricted double endTime</dt>
          <dd>
            <p>
              The upper bound of the animation interval expressed in
              seconds relative to the parent animation group.
            </p>
          </dd>
          <dt>readonly attribute AnimGroup parentGroup</dt>
          <dd>
            The parent animation group.
          </dd>
          <dt>readonly attribute double timeDrift</dt>
          <dd>
            The number of seconds that the actual item time of this item
            lags behind the time given by <code>parentGroup.iterationTime
            - startTime</code> as a result of pausing and seeking this item.
            It is initially zero as described in <a
            href="#pausing-a-timed-item" class="sectionRef"></a>.
          </dd>
          <dt>void start ()</dt>
          <dd>
            <p>
              Sets <code>startTime</code> to
              <code>parentGroup.iterationTime + timeFromNow</code>.
              If <code>parentGroup</code> is <code>null</code>, sets
              <code>startTime</code> to <code>timeFromNow</code>.
            </p>
            <div class="issue">
              Just use <code>play</code> for this?
            </div>
            <dl class="parameters">
              <dt>optional double timeFromNow = 0</dt>
              <dd>
                The number of seconds relative to the iteration time of the
                parent group at which the item should start.
              </dd>
            </dl>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>InvalidStateError</code></dt>
              <dd>
                Raised if <code>parentGroup</code> is a sequence animation group
                (see <a
                href="#the-start-time-of-children-of-a-sequence-animation-group"
                class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>void stop ()</dt>
          <dd>
            <p>
              Updates <code>animationDuration</code> such that the upper bound
              of the animation interval coincides with the current time plus any
              offset specified by <code>timeFromNow</code> unless doing so would
              make the <code>animationDuration</code> negative, in which case it
              it set to zero as per the usual clamping behavior for
              <code>animationDuration</code>.
            </p>
            <p>
              Specifically, <code>animationDuration</code> is set to
              <code>max(0, <a>item time</a> + timeFromNow -
                    startTime - timing.startDelay)</code>.
              If <a>item time</a> is <code>null</code> it is taken to be zero
              for the purposes of calculating the
              <code>animationDuration</code>.
            </p>
            <div class="issue">
              Just use <code>pause</code> for this?
            </div>
            <p class="note">
              Note that even after an item has stopped it may, depending on its
              <a href="#animation-fill-behavior">fill mode</a>,
              still affect its target.
              To completely remove the influence of the item, use
              <code>cancel()</code>.
            </p>
            <dl class="parameters">
              <dt>optional double timeFromNow = 0</dt>
              <dd>
                The number of seconds relative to the iteration time of the
                parent group at which the item should stop.
              </dd>
            </dl>
          </dd>
          <dt>attribute boolean locallyPaused</dt>
          <dd>
            <p>
              The pause state of this timed item.
              Initially <code>false</code> except for the document timeline
              where it is initially true (see <a href="#start-of-the-timeline"
              class="sectionRef"></a>).
            </p>
            <p class="issue">
              Should this be writeable?
              Once we integrate with media controllers we might want to make
              this writeable only when not associated with a media controller
              much like things currently work in HTML5.
            </p>
          </dd>
          <dt>readonly attribute boolean paused</dt>
          <dd>
            Indicates if this element or one of its ancestors is paused.
            This will be true if an only if <code>true</code> if the
            <code>locallyPaused</code> state of this object <em>or one of its
            ancestor animation groups</em> is <code>true</code>.
          </dd>
          <dt>void pause ()</dt>
          <dd>
            Sets <code>locallyPaused</code> to <code>true</code>.
            <p class="annotation">
              This method is intended to behave in a comparable manner to
              <a
              href="http://dev.w3.org/html5/spec/media-elements.html#media-elements">HTMLMediaElement</a>'s <a
              href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-pause">pause
              method</a>.
            </p>
          </dd>
          <dt>void play ()</dt>
          <dd>
            <p>
              Unpauses this item and, if the item is not currently animating,
              seeks to the beginning of the <a>animation interval</a> by taking
              the following steps.
            </p>
            <ol>
              <li>If <code>totalTime &gt; totalDuration</code> and
                  <code>timing.playbackRate &ge; 0</code>, set
                  <code>totalTime</code> to <code>timing.startDelay</code>.</li>
              <li>Set <code>locallyPaused</code> to <code>false</code>.</li>
            </ol>
            <p>
              To unpause the item without seeking, set
              <code>locallyPaused</code> to <code>false</code>.
            </p>
            <p class="annotation">
              This method is intended to behave in a comparable manner to
              <a
              href="http://dev.w3.org/html5/spec/media-elements.html#media-elements">HTMLMediaElement</a>'s <a
              href="http://dev.w3.org/html5/spec/media-elements.html#dom-media-play">play
              method</a>.
            </p>
          </dd>
          <dt>void changePlaybackRate (double playbackRate)</dt>
          <dd>
            <p>
              Updates the speed of the timed item such that it produces a smooth
              change.
            </p>
            <p>
              In particular:
            </p>
            <ul>
              <li>the <a>adjusted animation time</a> will not change,</li>
              <li>if the direction changes, <code>timing.fill</code> will be
                  inverted to prevent sudden jumps in output, and</li>
              <li>if the current <a>item time</a> is outside the animation
                  interval the distance from the interval is scaled according
                  to the change in speed.</li>
            </ul>
            <p>
              The smooth change is achieved using the following steps:
            </p>
            <ol>
              <li>Let <var>previous rate</var> be the value of
                  <code>timing.playbackRate</code> prior to updating it.</li>
              <li>Update <code>timing.playbackRate</code> to the passed-in
                  <code>playbackRate</code> parameter.</li>
              <li>Let <var>new rate</var> be the updated value of
                  <code>timing.playbackRate</code>.</li> 
              <li>If either <var>previous rate</var> or <var>new rate</var>
                  are zero, return.</li>
              <li>Invert the fill mode as follows:
                <dl class="switch">
                  <dt>If <code>timing.fill</code> is
                      <code>"forwards"</code>,</dt>
                  <dd>
                    Set <code>timing.fill</code> to <code>"backwards"</code>.
                  </dd>
                  <dt>If <code>timing.fill</code> is
                      <code>"backwards"</code>,</dt>
                  <dd>
                    Set <code>timing.fill</code> to <code>"forwards"</code>.
                  </dd>
                  <dt>Otherwise,</dt>
                  <dd>Leave <code>timing.fill</code> as is.</dd>
                </dl>
              </li>
              <li>If <a>item time</a> is <code>null</code>, return.</li>
              <li>Update the value of <code>animationDuration</code> if
                  necessary (that is, if <code>animationDuration</code> reflects
                  the <a>intrinsic animation duration</a>), applying the updated
                  value for <code>timing.playbackRate</code>.</li>
              <li>Calculate the <var>seek adjustment</var> according to the
                  following formula:
                  <code><var>seek adjustment</var> =
                  (<a>item time</a> - <code>timing.startDelay</code>) *
                  (1 - <var>previous rate</var> / <var>new rate</var>)</code>.
                  </li>
              <li>If the sign of <var>new rate</var> and <var>previous
                  rate</var> differs, subtract from the <var>seek
                  adjustment</var> the updated value of
                  <code>animationDuration</code>.</li>
              <li>Let <var>seek time</var> be the result of the following
                  formula:
                  <code><a>item time</a>
                    - <var>seek adjustment</var></code>.</li>
              <li>Set <code>totalTime</code> to <var>seek time</var>.</li>
            </ol>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this item is a linked item, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>void reverse ()</dt>
          <dd>
            <p>
              Reverses this animation such that the reverse animation
              immediately begins reversing from its current point.
              Note that this means that an animation that has yet to begin,
              calling <code>reverse</code> will mean that it never starts.
            </p>
            <li>
              Calculate <var>seek time</var> as follows:
            </li>
              <dl class="switch">
                <dt>If <a>item time</a> is null,</dt>
                <dd>
                  Let <var>seek time</var> be zero.
                </dd>
                <dt>If <code><a>item time</a> &lt;
                  timing.startDelay</code>,</dt>
                <dd>
                  Let <var>seek time</var> be 
                  <code>timing.startDelay + animationDuration</code>.
                </dd>
                <dt>If <code><a>item time</a> &gt; timing.startDelay
                  + animationDuration</code>,</dt>
                <dd>
                  Let <var>seek time</var> be <code>timing.startDelay</code>.
                </dd>
                <dt>Otherwise,</dt>
                <dd>
                  Let <var>seek time</var> be
                  <code>animationDuration - <a>animationTime</a></code>.
                </dd>
              </dl>
            </li>
            <li>
              Call <code>changePlaybackRate(-timing.playbackRate)</code>.
            </li>
            <li>
              Set <code>totalTime</code> to <var>seek time</var>.
            </li>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this item is a linked item, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>void cancel ()</dt>
          <dd>
            <p>
              Removes the timed item from its parent group. As a result, the
              timed item will no longer affect its target.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this item is a linked item, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
            <p class="feedbackWanted">
              Is this exception necessary? It will depend how we approach group
              templates.
            </p>
          </dd>
        </dl>
        <div class="todo">
          <p>
            Do we need a means for getting the startTime etc. in document
            time (i.e. in terms of the root time container)?
          </p>
        </div>
      </section>
      <section>
        <h3>Timing model common definitions</h3>
        <p>
          In order to calculate various properties of the timing model the
          following common definitions are used.
        </p>
        <ul>
          <li><dfn>iteration start</dfn> =
              <code>max(0, min(timing.iterationStart,
                               timing.iterationCount))</code></li>
          <li><dfn>iteration count</dfn> =
              <code>max(0, timing.iterationCount)</code></li>
        </ul>
      </section>
      <section>
        <h3>Calculating the iteration duration</h3>
        <p>
          The <dfn>iteration duration</dfn> is calculated according to the
          following steps:
        </p>
        <dl class="switch">
          <dt>
            If the <code>timing.duration</code> timing property is set
            to a numerical value greater than or equal to zero (including
            positive infinity),
          </dt>
          <dd>
            return <code>timing.duration</code>.
          </dd>
          <dt>
            Otherwise,
          </dt>
          <dd>
            return the item's <var>intrinsic duration</var>.
          </dd>
        </dl>
        <p>
          The value of an item's <var>intrinsic duration</var> depends on
          the type of the item. For animations the <var>intrinsic
          duration</var> is <code>Infinity</code>.
        </p>
        <p>
          The intrinsic duration for animation groups and media items
          is described under <a
      href="#the-intrinsic-duration-of-a-parallel-animation-group"
          class="sectionRef"></a>, <a
      href="#the-intrinsic-duration-of-a-sequence-animation-group"
          class="sectionRef"></a>,
          and <a
          href="#the-intrinsic-duration-of-a-media-item"
          class="sectionRef"></a>.
        </p>
      </section>
      <section>
        <h3>Calculating the intrinsic animation duration</h3>
        <p>
          The <dfn>intrinsic animation duration</dfn> is calculated according to
          the following steps:
        </p>
        <ol>
          <li>
            Let the <var>repeated duration</var> be <code><a>iteration
            duration</a> * <a>iteration count</a></code>.
          </li>
          <li>
            If <code>timing.playbackRate</code> is zero, return
            <code>Infinity</code>.
          </li>
          <li>
            Otherwise, return <code><var>repeated duration</var>
            / abs(<code>timing.playbackRate</code>)</code>.
          </li>
        </ol>
      </section>
      <section>
        <h3>Calculating the item time</h3>
        <p>
          The <dfn>item time</dfn> is calculated according to the following
          equation:
        </p>
        <blockquote>
          <code><var>item time</var> = parentGroup.iterationTime
            - startTime - timeDrift</code>
        </blockquote>
        <p>
          If the timed item is does not have a parent animation group, the
          <var>item time</var> is <code>null</code>.
        </p>
        <p class="todo">
          Need to define this for the document timeline.
        </p>
      </section>
      <section>
        <h3>Calculating the animation time</h3>
        <p>
          The <dfn>animation time</dfn> is based on the <a>item time</a>
          and <var>start delay</var>.
          It is defined only when the timed item is <a>in effect</a> and is
          calculated according to the following steps:
        </p>
        <ol>
          <li>
            If <a>item time</a> is <code>null</code>, return <code>null</code>.
          </li>
          <li>
            If <code><a>item time</a> &lt; timing.startDelay</code>
            the result depends on the <var>fill mode</var> as follows,
            <dl class="switch">
              <dt>
                If the <var>fill mode</var> is <em>backwards</em> or
                <em>both</em>,
              </dt>
              <dd>
                return zero.
              <dd>
              <dt>
                Otherwise,
              </dt>
              <dd>
                return <code>null</code>.
              </dd>
            </dl>
          </li>
          <li>
            If <code><a>item time</a> &lt; timing.startDelay +
            animationDuration</code>, return
            <code><a>item time</a> - timing.startDelay</code>.
          </li>
          <li>
            Otherwise, the result depends on the <var>fill mode</var> as
            follows,
            <dl class="switch">
              <dt>
                If the <var>fill mode</var> is <em>forwards</em> or
                <em>both</em>,
              </dt>
              <dd>
                return <code>animationDuration</code>.
              <dd>
              <dt>
                Otherwise,
              </dt>
              <dd>
                return <code>null</code>.
              </dd>
            </dl>
          </li>
        </ol>
        <section>
          <h4>Calculating the adjusted animation time</h4>
          <p>
            Before the <a>animation time</a> can be converted to an
            <var>iteration time</var>
            we must factor in the animation's <var>playback rate</var> and
            <a>iteration start</a>. This is called the <a>adjusted
            animation time</a>.
          </p>
          <p>
            The <dfn>adjusted animation time</dfn> is calculated according to
            the following steps:
          </p>
          <ol>
            <li>
              If the <a>animation time</a> is <code>null</code>, return
              <code>null</code>.
            </li>
            <li>
              Let the <var>start offset</var> be <code><a>iteration start</a>
              * <a>iteration duration</a></code>.
            </li>
            <li>
              Return the adjusted animation time based on the
              <code>timing.playbackRate</code> as follows,
              <dl class="switch">
                <dt>If <code>timing.playbackRate</code> is negative,</dt>
                <dd>
                Return <code>(<a>animation time</a> -
                              animationDuration) * timing.playbackRate
                        + <var>start offset</var></code>.
                </dd>
                <dt>Otherwise,</dt>
                <dd>
                  Return <code><a>animation time</a> * timing.playbackRate
                  + <var>start offset</var></code>.
                </dd>
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h3>Calculating the iteration time</h3>
        <p>
          The iteration time is calculated by first dividing the <a>adjusted
          animation time</a> into intervals.
          This is called the <var>unscaled iteration time</var>.
          Following this, timing manipulations specified on the timed item are
          applied to the <var>unscaled iteration time</var> to produce the
          <var>iteration time</var>.
        </p>
        <section>
          <h4>Calculating the unscaled iteration time</h4>
          <p>
            The <dfn>unscaled iteration time</dfn> is calculated according to
            the following steps:
          </p>
          <ol>
            <li>
              If the <a>item time</a> is <code>null</code>,
              return <code>null</code>.
            </li>
            <li>
              If the <a>iteration duration</a> is zero, return zero.
            </li>
            <li>
              Calculate the <var>start offset</var> as described in
              <a href="#calculating-the-adjusted-animation-time"
              class="sectionRef"></a>.
            </li>
            <li>
              Calculate the <var>repeated duration</var> as described in
              <a href="#calculating-the-intrinsic-animation-duration"
              class="sectionRef"></a>.
            </li>
            <li>
              If <code><a>adjusted animation time</a> -
                       <a>start offset</a></code> equals the
              <var>repeated duration</var>, and
              <code>(<a>iteration count</a> - <a>iteration start</a>) % 1</code>
              is zero, return the <var>iteration duration</var>.
            </li>
            <li>
              Otherwise, return <code><a>adjusted animation time</a>
              % <var>iteration duration</var></code>.
            </li>
          </ol>
        </section>
        <section>
          <h4>Applying time manipulations</h4>
          <p>
            The <a>unscaled iteration time</a> is converted into the
            <dfn>iteration time</dfn> using the following steps:
          <ol>
            <li>
              If the <var>unscaled iteration time</var> is <code>null</code>,
              return <code>null</code>.
            </li>
            <li>
              Let <var>scaled iteration time</var> be the result of applying any
              timing function defined for this timed element to the
              <var>unscaled iteration time</var>. <span class="todo">(Need more
              detail here, or a link to where this is defined.)</span>
            </li>
            <li>
              Calculate the <var>current direction</var> using the first
              matching condition from the following list:
              <dl class="switch">
                <dt>
                  If the direction is normal,
                </dt>
                <dd>Let the <var>current direction</var> be forwards.</dd>
                <dt>
                  If the direction is reverse,
                </dt>
                <dd>Let the <var>current direction</var> be reverse.</dd>
                <dt>
                  Otherwise,
                </dt>
                <dd>
                  <ol>
                    <li>
                      Let <var>d</var> be the <a>current iteration</a>.
                    </li>
                    <li>
                      If the direction is alternate-reverse increment
                      <var>d</var> by 1.
                    </li>
                    <li>
                      If the animation is not animating, and the
                      <code>animationDuration</code> is a positive multiple of
                      the <a>iteration duration</a> increment <var>d</var>
                      by 1.
                    </li>
                    <li>
                      If <code><var>d</var> % 2 != 0</code>, let the
                      <var>current direction</var> be forwards, otherwise let
                      the <var>current direction</var> be reverse.
                    </li>
                  </ol>
                </dd>
              </dl>
            </li>
            <li>
              If the <var>current direction</var> is forwards then return
              the <var>scaled iteration time</var>.
              <p>
                Otherwise, return the <a>iteration duration</a>
                - <var>scaled iteration time</var>.
              </p>
            </li>
          </ol>
          <p class="note">
            Applying the reverse behavior after applying the timing function
            means that ease-in becomes ease-out on reverse, however it avoids
            jumps in values when reversing part-way.
          </p>
        </section>
        <section>
          <h4>Calculating the time fraction</h4>
          <p>
            The <dfn>time fraction</dfn> is given by dividing the <var>iteration
            time</var> by the <a>iteration duration</a>.
          </p>
        </section>
        <section>
          <h4>Calculating the current iteration</h4>
          <p>
            The <dfn>current iteration</dfn> can be calculated from the
            following steps:
          </p>
          <ol>
            <li>
              If the <a>item time</a> is <code>null</code>, return
              <code>null</code>.
            </li>
            <li>
              If the <a>adjusted animation time</a> is zero, return zero.
            </li>
            <li>
              If the <a>iteration duration</a> is zero, return
              <code>floor(<a>iteration count</a>)</code>.
            </li>
            <li>
              Return <code>floor(<a>adjusted animation time</a> /
              <a>iteration duration</a>)</code>.
              <p class="note">
                If the <a>iteration duration</a> is infinite, the
                result of <code>floor(<a>adjusted animation time</a> /
                <a>iteration duration</a>)</code> will be zero as defined by
                IEEE 754-2008.
              </p>
            </li>
          </ol>
        </section>
      </section>
      <section>
        <h3>Pausing a timed item</h3>
        <p class="todo">
          This is all quite wrong and needs to be re-written.
        </p>
        <div class="informative">
          <p>
            Timed items may be paused and resumed independently of the parent
            animation group they belong to.
            The effect is that the time of the item lags behind that of its
            parent.
            This lag is called the <var>time drift</var> and acts as an
            additional delay added to the <var>start time</var> of the item.
          </p>
          <p>
            Timed elements that do not have a parent animation group may still
            be paused and resumed.
            However, except for the case of the document timeline, there will be
            no observable effect until the element is attached to a parent
            animation group.
          </p>
        </div>
        <p>
          The <var>time drift</var> produced by pausing can be calculated as
          follows:
        </p>
        <ol>
          <li>
            Let <var>time drift</var> be initially zero.
          </li>
          <li>
            When the pause state is newly true, record the <var>parent iteration
            time</var> as <var>pause start time</var>.
          </li>
          <li>
            On the next sample, increment <var>time drift</var> by
            <code><var>parent iteration time</var> - <var>pause start
            time</var></code>.
          </li>
          <li>
            Update <var>pause start time</var> to <var>parent iteration
            time</var>.
          </li>
          <li>
            Repeat steps 3 and 4 for each sample while paused and when the pause
            state is newly false.
          </li>
        </ol>
        <p>
          An important characteristic of the above procedure is that the
          <var>time drift</var> continues to accumulate while the
          item is paused.
          As a result, the <var>time drift</var> must be calculated prior to
          calculating the <a>item time</a>.
        </p>
        <p class="todo">
          Need to clarify what happens if the item is moved around the tree.
          Basically, update the drift on bind/unbind, use zero as the parent
          iteration time when there is none, etc.
        </p>
      </section>
      <section>
        <h3>Seeking a timed item</h3>
        <p>
          Seeking, like pausing, has the effect of causing a timed item's
          time to drift from that of its parent animation group.
        </p>
        <p>
          When a seek operation is performed, the <var>time drift</var> is set
          according to the following formula:
        </p>
        <blockquote>
          <code><var>time drift</var> = <var>parent iteration time</var>
            - startTime - <var>seek time</var></code>
        </blockquote>
        <p>where:</p>
        <ul>
          <li>
          <var>parent iteration time</var> - is
            <code>parentGroup.iterationTime</code> if it is not
            <code>null</code>, otherwise it is zero.
          </li>
          <li>
            <var>seek time</var> - is the time to seek to expressed in the
            item time space.
          </li>
        </ul>
        <p>
          The animation events dispatched when a seek is performed are described
          in <a href="#animation-events" class="sectionRef"></a>.
        </p>
        <div class="informative">
          <p>
            Note that seeking a timed item does not reset the state of the timed
            item or its children.
            For example, if an application is configured to produce new
            animations in response to animation end events, seeking the document
            timeline backwards will not remove the created animations.
            As a result, a naive application may create overlapping animations
            on subsequent replays.  It is the application's responsibility to
            restore the original state of the document in such situations.
          </p>
        </div>
      </section>
    </section>

    <section>
      <h2>Controlling animation playback rate</h2>
      <p class="todo">
        TBD.
        Need to define timing functions and the ability to provide custom
        functions to scale a time.
        Not even sure what this section should be called or if it should be
        subsection of the previous section.
        &ldquo;Scaling the time&rdquo;?
      </p>
      <h3>The <code>TimingFunc</code> interface</h3>
      <p class="todo">
        TBD.
      </p>
      <dl title="interface TimingFunc" class="idl">
        <dt>TimingFunc clone()</dt>
        <dd>
          <p class="todo">Needed for <code>Timing.clone</code>.</p>
        </dd>
      </dl>
    </section>

    <section>
      <h2>Grouping and synchronization</h2>
      <div class="informative">
      <p>
        While it is possible to set the timing properties of animations
        individually, it is often useful to bundle animations together and
        control their timing as a group.
      </p>
      <p>
        This can be used to share common timing properties as illustrated below:
      </p>
      <div class="figure">
        <img src="img/grouping-delay.svg" width="800">
      </div>
      <p class="caption">
        Using groups to share common timing properties.<br>
        (a) Shows setting a delay of 5 seconds on individual animations.<br>
        (b) Produces the same effect by setting the delay on the group.
      </p>
      <p>
        As well as sharing timing information, by grouping animations together
        they can be seeked, paused, and stopped as a unit.
      </p>
      </div>
      <section class="informative">
        <h3>Relationship of group time to child time</h3>
        <p>
          The timing of the children of a group is based on the timing of the
          group. Specifically, times for the children are based on the parent's
          <em>iteration time</em>. That is, the children animate <em>inside</em>
          an iteration of the parent.
        </p>
        <p>
          As an example, consider repetition. If a group has an iteration count
          of 2, then the children of of the group will all play twice since they
          effectively play <em>inside</em> the group's iterations.
        </p>
        <div class="figure">
          <img src="img/grouping-repetition.svg" width="600">
        </div>
        <p class="caption">
          Since children of an animation group base their timing on the group's
          <var>iteration time</var>, when the group repeats, the children play
          again.
        </p>
        <p>
          If an iteration count is specified for the children of a group as well
          as for the group the effect is as if the iteration count of the group
          was multiplied with the iteration count of the children.
        </p>
        <div class="figure">
          <img src="img/grouping-repetition-and-animation-repetition.svg"
            width="600">
        </div>
        <p class="caption">
          Specifying an iteration count of 2 on an animation group and an
          iteration count of 3 on one of its children results in that child
          playing 6 times.
        </p>
        <p>
          A further result of the children of a group basing their timing on the
          group's <var>iteration time</var> is that they cannot animate outside
          of the group's <a>animation interval</a>.
          This is because the <var>iteration time</var> of a group will not
          change outside its animation interval.
          This allows groups to clip the playback of their children.
        </p>
        <div class="figure">
          <img src="img/grouping-clipping.svg" width="600">
        </div>
        <p class="caption">
          In the first instance, an animation has a negative delay and an
          infinite iteration count.<br>
          However, when a similar animation is placed inside a group with
          a specified duration it has the effect of clipping the animation's
          duration.
        </p>
        <p>
          Some further consequences of group children basing their timing on
          their parent group's <var>iteration time</var> are:
        </p>
        <ul>
          <li>
            Setting the playback rate of an animation group will speed up or
            slow down all children.
          </li>
          <li>
            Changing the playback direction of an animation group will change
            the direction of all children.
          </li>
          <li>
            Applying a timing function to an animation group will affect the
            playback rate of all children.
          </li>
        </p>
      </section>
      <section class="informative">
        <h3>Types of groups</h3>
        <p>
          Groups can be used to provide synchronization behavior for its
          children.
          For example, one type of group runs its children in parallel, whilst
          another type runs the children in sequence.
        </p>
        <p>
          Compare the two arrangements illustrated below:
        </p>
        <div class="figure">
          <img src="img/grouping-types.svg" width="600">
        </div>
        <p class="caption">
          Two types of animation groups.<br>
          (a) is a parallel group where all the children run simultaneously.<br>
          (b) is a sequence group where the children run in turn.
        </p>
        <p>
          Groups can also contain other groups which allows for more
          sophisticated synchronization.
        </p>
        <div class="figure">
          <img src="img/grouping-nesting.svg" width="600">
        </div>
        <p class="caption">
          A sequence animation group that contains a parallel animation group as
          a child.<br>
          The parallel group waits for the previous child of the sequence
          group to finish, and then the children of the parallel group play
          simultaneously.
          After they have finished the next child of the sequence group plays.
        </p>
        <p>
          Web Animations defines two types of animation groups.
        </p>
        <dl>
          <dt>Parallel groups</dt>
          <dd>
            Children of the group play simultaneously.
            The start time of children is taken as relative to the start of the
            current iteration of the group, that is, it is in the group's
            <em>iteration time space</em>.
          </dd>
          <dt>Sequence groups</dt>
          <dd>
            Children of the group play in turn beginning with the first child
            and proceeding to the last.
            Any start time specified on children is ignored and replaced with
            the time calculated using the procedure in <a
            href="#the-start-time-of-children-of-a-sequence-animation-group"
            class="sectionRef"></a>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The document timeline</h3>
        <p class="todo">
          Move all this to its own section later on.
        </p>
        <p>
          We have previously referred to the document timeline as the context in
          which animation takes places.
          Likewise we have referred to the <em>document time space</em> as the
          master time space which contains other time spaces.
          The document timeline is, in fact, a parallel animation group
          with the following special properties:
        </p>
        <ul>
          <li>
            It cannot be appended as a child of another group. As a result the
            <code>parentGroup</code> property returns <code>null</code>.
          </li>
          <li>
            Calls to <code>cancel()</code> will result in a DOMException of type
            HierarchyRequestError being thrown.
          </li>
          <li>
            <p>
              For properties that represent times in <em>parent iteration time
              space</em> a time space whose zero time is 00:00:00 UTC on
              1 January 1970 is used.
            </p>
            <p>
              As a result, the <var>parent iteration time</var> is the number of
              seconds from 00:00:00 UTC on 1 January 1970 to the current moment
              in UTC time.
            </p>
            <p class="issue">
              We should use a monotonically increasing timestamp here.
              Not one that can potentially skip due to clock adjustments.
            </p>
          </li>
          <li>
            It is initially paused as described in <a
              href="#initial-state-of-the-document-timeline"
              class="sectionRef"></a>.
          </li>
        </ul>
        <p class="todo">
          Move/copy exception behavior to the relevant properties / methods.
        </p>
        <section>
          <h4>Initial state of the document timeline</h4>
          <p>
            Unlike other timed items, the document timeline is initially paused.
            The moment at which the timeline becomes unpaused is defined in <a
              href="#start-of-the-timeline" class="sectionRef"></a>.
          </p>
          <p>
            On creating an <code>AnimationGroupInstance</code> corresponding to
            the document timeline, the following steps are performed.
          </p>
          <ol>
            <li>
              Set the <var>start time</var> to the current <var>parent
              iteration time</var> (i.e. the number of seconds since 00:00:00
              UTC on 1 January 1970).
            </li>
            <li>
              Set the <var>pause state</var> to <code>true</code>.
            </li>
          </ol>
          <p class="note">
            By setting the <var>start time</var> to the <var>parent iteration
            time</var> and then pausing the timeline, the start time is always
            well-defined.
            Furthermore, seeking the timeline before it is unpaused provides
            intuitive results without special casing the algorithm for seeking
            (see <a href="#seeking-a-timed-item" class="sectionRef"></a>).
          </p>
        </section>
        <section>
          <h4>Start of the timeline</h4>
          <p>
            The time at which the timeline will be automatically unpaused is
            determined by the <code>timelineStart</code> property on the
            <code>Document</code> object (see <a
            href="#extensions-to-the-document-interface"
            class="sectionRef"></a>). It can have the following values:
          </p>
          <dl title="enum AnimStartType" class="idl">
            <dt>onload</dt>
            <dd>
              <p>
                The moment immediately prior to dispatching the "load" event for
                the document.
              </p>
              <p>
                For HTML documents, this is the moment after the <a
                  href="http://dev.w3.org/html5/spec/dom.html#current-document-readiness">current
                  document readiness</a> has changed to "complete" but before
                dispatching the load event.  In terms of the timings defined in
                <a
                  href="http://test.w3.org/webperf/specs/NavigationTiming/">NAVIGATION-TIMING</a>
                <span class="todo">(Need to add NAVIGATION-TIMING to the
                  biblio)</span>, this occurs between the <em>domComplete</em>
                and <em>loadEventStart</em> timings.
              </p>
              <p>
                This is the default value.
              </p>
            </dd>
            <dt>onstart</dt>
            <dd>
              <p>
                The moment after the user agent stops parsing but before running
                scripts that are designated to execute when parsing finishes.
              </p>
              <p>
                For HTML documents, this occurs after updating the <a
                  href="http://dev.w3.org/html5/spec/dom.html#current-document-readiness">current
                  document readiness</a> to "interactive" (see <a
                href="http://dev.w3.org/html5/spec/the-end.html#the-end">the
                specified behavior for the end of parsing</a>), that is,
                after the <em>domInteractive</em> timing.
              </p>
            </dd>
            <dt>manual</dt>
            <dd>
              A moment infinitely distant in the future. That is, animation will
              not begin until <code>unpause</code> is called on the timeline.
            </dd>
          </dl>
          <p>
            For the <var>onload</var> and <var>onstart</var> values, it is not
            sufficient to simply the record the appropriate time and seek the
            animations accordingly at a later moment.
            Rather, the timeline must be actually unpaused at the appropriate
            moment such that scripts that execute during page loading (for
            example, in response to the load event) can make assumptions about
            the pause state of the timeline.
          </p>
          <p>
            Any call to <code>pause</code> or <code>unpause</code> on the
            timeline disables the automatic unpause behavior defined by the
            <code>timelineStart</code> property on the document.
            It is as if the <code>timelineStart</code> property were set to
            <var>manual</var>.
          </p>
          <div class="note">
            <p>
              The ability for script to override the <code>timelineStart</code>
              property by calling <code>pause</code> to indefinitely postpone
              the start of animation is necessary for backwards compatibility
              with SVG.
            </p>
            <p>
              This override behavior applies even if the timeline has already
              been unpaused since changing the <code>timelineStart</code>
              property could return the timeline to a state where the automatic
              unpause behavior would otherwise apply.
            </p>
          </div>
        </section>
        <section>
          <h4>Changing the timeline start</h4>
          <p>
            The <code>timelineStart</code> property may be changed at any time.
            The result of changing this property is as follows:
          </p>
          <ol>
            <li>
              If <code>pause</code> or <code>unpause</code> has been called on
              the timeline, return immediately.
            </li>
            <li>
              Let <var>autostart</var> be the moment at which the timeline would
              be unpaused corresponding to the new value of
              <code>timelineStart</code> as defined in <a
              href="#start-of-the-timeline" class="sectionRef"></a>.
            </li>
            <li>
              Let <var>now</var> be the <var>parent iteration time</var>.
            </li>
            <li>
              If <var>autostart</var> &le; <var>now</var>, set the
              <var>pause state</var> to false.
            </li>
            <li>
              If <var>autostart</var> &gt; <var>now</var>, set the <var>start
              pause state</var> to true.
            </li>
            <li>
              If the pause state is newly true seek the timeline to
              <var>autostart</var> - <var>now</var>.
            </li>
            <li>
              If the pause state is newly false seek the timeline to 0.
            </li>
          </ol>
        </section>
        <section>
          <h4>Extensions to the <code>Document</code> interface</h4>
          <p>
            To provide access to the document timeline the following extensions
            to the <code>Document</code> interface are required.
          </p>
          <dl title="partial interface Document" class="idl">
            <dt>readonly attribute ParAnimGroup animationTimeline</dt>
            <dd>
              The animation group corresponding to the root of the document.
              This group exhibits the special behavior described for the root
              animation group in <a href="#the-document-timeline"
              class="sectionRef"></a>.
            </dd>
            <dt>attribute AnimStartType timelineStart</dt>
            <dd>
              Sets the time at which the animation timeline will begin animating
              unless it is overridden by script as defined in <a
              href="#start-of-the-timeline" class="sectionRef"></a>.
              Changes to this property are defined in <a
              href="#changing-the-timeline-start" class="sectionRef"></a>.
              Initialized to "onload".
            </dd>
          </dl>
        </section>
        <section>
          <h3>Timeline of document resources</h3>
          <p>
            Documents may include external animated resources, for example, via
            the <code>&lt;object&gt;</code> or <code>&lt;use&gt;</code>
            elements. These external resources will often have their own
            Document object and their own timeline. In order to synchronize
            these timelines the same approaches can be applied as with described
            under <a href="#synchronizing-with-media" class="sectionRef"></a>.
          </p>
        </section>
      </section>
      <section>
        <h3>The <code>AnimGroup</code> interface</h3>
        <p>
          Represents a list of timed items.
        </p>
        <p>
          The <code>AnimGroup</code> interface supports indexed
          properties with indices in the range 0 &le; <var>index</var> &lt;
          <code>group.size</code>. 
        </p>
        <dl title="interface AnimGroup : TimedItem"
          class="idl">
          <dt>readonly attribute unsigned long length</dt>
          <dd>
            The number of timed items in the group.
          </dd>
          <dt>readonly attribute AnimGroupTemplate? template</dt>
          <dd>
            <p>
              For linked animation groups (see <a href="#animation-templates"
              class="sectionRef"></a>), the <a>AnimGroupTemplate</a> object
              from which this object derives its values.
              For animations that are not linked to a template, this property is
              <code>null</code>.
            </p>
            <p class="feedbackWanted">
              Make this writeable?
            </p>
          </dd>
          <dt>void clear ()</dt>
          <dd>
            <p>
              Removes all child timed items from the group.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>getter TimedItem? (unsigned long index)</dt>
          <dd>
            <p>
              Returns the item at <code>index</code>.
              If <code>index</code> is greater than or equal to
              <code>length</code> returns <code>null</code>.
            </p>
          </dd>
          <dt>setter TimedItem (unsigned long index, TimedItem newItem)</dt>
          <dd>
            <p>
              Replaces the item at <code>index</code> with <code>newItem</code>
              by calling <code>splice(index, 1, newItem)</code>.
            </p>
            <p>
              No attempt is made to check if the item at <code>index</code> is
              already <code>newItem</code>. In such a case, <code>newItem</code>
              will be removed from this group and re-added as per the usual
              operation of <code>slice</code>.
            </p>
            <p>
              Returns <code>newItem</code>.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>HierarchyRequestError</code></dt>
              <dd>
                Raised if <code>newItem</code> is the timeline for a document
                (see <a href="#the-document-timeline" class="sectionRef"></a>).
              </dd>
              <dt>DOMException of type <code>IndexSizeError</code></dt>
              <dd>
                Raised if <code>index</code> is outside of the range 0 &le;
                <var>index</var> &lt; <code>group.length</code>.
              </dd>
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
            <div class="note">
              <p>
                Whilst <code>splice</code> allows negative indices,
                WebIDL requires index property setters to take an index of type
                <code>unsigned long</code> and hence <code>index</code> is
                restricted to the range 0 &le; <var>index</var> &lt;
                <code>group.length</code>.
              </p>
            </div>
          </dd>
          <dt>sequence&lt;TimedItem&gt; add (TimedItem newItem,
                                             TimedItem... otherItems)</dt>
          <dd>
            <p>
              Add <code>newItem</code> and each <code>otherItems</code> as the
              last item(s) in the group by calling <code>splice(group.length, 0,
              newItem, otherItem1, ... otherItemN)</code>.
            </p>
            <p>
              Returns a sequence containing the added items:
              <code>[newItem, otherItem1, ... otherItemN]</code>.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>HierarchyRequestError</code></dt>
              <dd>
                Raised if any of the items to add is the timeline for a document
                (see <a href="#the-document-timeline" class="sectionRef"></a>).
                If this exception is thrown none of the <code>newItem</code>
                objects will be added to the group.
              </dd>
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>sequence&lt;TimedItem&gt; remove (
                long index, optional unsigned long count)</dt>
          <dd>
            <p>
              Removes the item(s) at <code>index</code> by calling
              <code>splice(index, count)</code>.
            </p>
            <p>
              Returns the removed items.
            </p>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>
            sequence&lt;TimedItem&gt; splice ()
          </dt>
          <dd>
            <p>
              Modifies the list of children of this group by first removing
              <code>deleteCount</code> items from <code>start</code> followed by
              adding <code>newItems</code> at the same point.
            </p>
            <p>
              The operation of slice is based on <a
                href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf#page=140">ECMAScript 5's
                Array.prototype.splice</a>.
            </p>
            <p>
              Returns a sequence of the items removed from group during the
              removal step (regardless of whether these items were re-added
              during the addition step).
            </p>
            <dl class="parameters">
              <dt>long start</dt>
              <dd>
                The index at which items should be removed and inserted.
                Negative indices represent an offset from the end of the list of
                items.
                This value is clamped to the range [-<code>length</code>,
                <code>length</code>].
              </dd>
              <dt>unsigned long deleteCount</dt>
              <dd>
                The number of items to remove from the group beginning at
                <code>start</code>.
                Negative values are clamped to zero, and all other values are
                clamped such that
                0 &lt; <code>start</code> + <code>deleteCount</code> &le;
                length.
              </dd>
              <dt>sequence&lt;TimedItem&gt; newItems</dt>
              <dd>
                The items to be added at <code>start</code>.
                Each item, if it already has a parent group (including this
                group), is first removed from its parent group before being
                added to this group.
              </dd>
            </dl>
            <p>
              Exceptions:
            </p>
            <dl class="exceptions">
              <dt>DOMException of type <code>HierarchyRequestError</code></dt>
              <dd>
                Raised if any of the items in <code>newItem</code> is the
                timeline for a document (see <a href="#the-document-timeline"
                class="sectionRef"></a>).
              </dd>
              <dt>DOMException of type
                  <code>NoModificationAllowedError</code></dt>
              <dd>
                Raised if this group is a linked group, that is, if
                <code>template</code> is not <code>null</code>
                (see <a href="#animation-templates" class="sectionRef"></a>).
              </dd>
            </dl>
          </dd>
          <dt>
            sequence&lt;TimedItem&gt; splice (long start,
              unsigned long deleteCount, TimedItem... newItem)
          </dt>
          <dd>
            An overload of <code>splice</code> to take a variadic list of items
            rather than requiring a sequence.
            The operation is identical to <code>splice(unsigned long start,
            unsigned long deleteCount, sequence&lt;TimedItem&gt;
            newItems)</code>.
          </dd>
          <dt>long indexOf (TimedItem item)</dt>
          <dd>
            Returns the index of <code>item</code> within the group.
            If <code>item</code> is not in the group, returns <code>-1</code>.
          </dd>
          <dt>AnimGroupTemplate? unlink()</dt>
          <dd>
            <p class="todo">
              Makes this group independent of the template with which it is
              associated if any.
              See <a href="#animation-templates" class="sectionRef"></a>.
              Does this recurse through children and unlink them too?
            </p>
            <p>
              After this method returns, the <code>template</code>
              property will be <code>null</code>.
            </p>
            <p>
              Returns the previous value of <code>template</code>.
            </p>
          </dd>
          <dt>sequence&lt;Anim&gt; getActiveAnimations ()</dt>
          <dd>
            Returns all descendent <code>Anim</code> objects
            that are <a>in effect</a>.
            The returned sequence is a snapshot (i.e. not live) representing the
            state of animations that corresponds to the time returned by the
            <code>iterationTime</code> property of this
            <code>AnimGroup</code> object when this method was
            called.
          </dd>
          <dt>sequence&lt;Anim&gt; getAnimationsForElement (Element elem)</dt>
          <dd>
            Returns all descendent <code>Anim</code> objects
            whose <code>targetElement</code> is <code>elem</code>.
            As with <code>getActiveAnimations</code>, the returned sequence is
            a snapshot (i.e. not live) representing the state of animation
            when this method was called.
          </dd>
        </dl>
      </section>
      <section>
        <h3>Parallel animation groups</h3>
        <p>
          Parallel animation group run their children such they potentially play
          simultaneously.
          The start time of each child depends on its own <code>startTime</code>
          property.
        </p>
        <section>
          <h4>The intrinsic duration of a parallel animation group</h4>
          <p>
            The intrinsic duration of a parallel animation group is
            the maximum of the <code>endTime</code> properties of each
            child <code>TimedItem</code>.
          </p>
          <p>
            If the group has no children then the intrinsic duration is zero.
          </p>
        </section>
        <section>
          <h4>The <code>ParAnimGroup</code> interface</h4>
          <p>
            Parallel animation groups are represented by
            <code>ParAnimGroup</code> objects.
          </p>
          <dl title="interface ParAnimGroup : AnimGroup"
            class="idl">
          </dl>
        </section>
      </section>
      <section>
        <h3>Sequence animation groups</h3>
        <p>
          Sequence animation groups run their children in turn
          following their order in the group.
          This ordering is achieved by adjusting the <var>start time</var> of
          each child in the group.
        </p>
        <div class="informative">
          <p>
            Since the <var>start delay</var> is added to the <var>start
            time</var>, it can be used to adjust the timing of the <a>animation
            interval</a> relative to calculated <var>start time</var> as shown
            in the following diagram.
          </p>
          <div class="figure">
            <img src="img/sequence-groups-and-start-delays.svg" width="600">
          </div>
          <p>
            A negative <var>start delay</var> can be used to cause the
            <a>animation interval</a> of two children to overlap.
            Note that the <var>start delay</var> affects the <var>start
            time</var> of subsequent children in the group.
          </p>
        </div>
        <section>
          <h4>The start time of children of a sequence animation group</h4>
          <p>
            The start time for the children of a sequence animation group
            is calculated according to the following procedure:
          </p>
          <ol>
            <li>Let the <var>accumulated start time</var> be zero.
            <li>
              Iterate over each child in the group beginning with the first item
              in the group and proceeding to the last.
              For each child perform the following steps:
              <ol>
                <li>
                  Let the start time of the child be <var>accumulated start
                  time</var>.
                </li>
                <li>
                  Increment <var>accumulated start time</var> by
                  <code>max(0, totalDuration)</code>.
                </li>
              </ol>
            </li>
          </ol>
          <p class="todo">
            Where does the drift get incorporated here?
            Do we defer it to the parent?
            How should a sequence container behave if you seek backwards and
            a child is paused?
          </p>
          <p class="note">
            When <code>animationDuration</code> is positive infinity the
            behavior is defined by IEEE 754-2008.
            As a result, if any of the children of a sequence animation group
            has an infinite animation duration, any children that occur
            later in the sequence will not play.
          </p>
        </section>
        <section>
          <h4>The intrinsic duration of a sequence animation group</h4>
          <p>
            The instrinsic duration of a sequence animation group is
            equivalent to the <var>start time</var> of a hypothetical child
            appended to the group's children.
          </p>
        </section>
        <section>
          <h4>The <code>SeqAnimGroup</code> interface</h4>
          <p>
            Sequence animation groups are represented by
            <code>SeqAnimGroup</code> objects.
          </p>
          <dl title="interface SeqAnimGroup : AnimGroup"
            class="idl">
          </dl>
        </section>
      </section>
    </section>

    <section>
      <h2>Animation values</h2>
      <div class="informative">
        <p>
          The Web Animations <em>animation model</em> takes the <a>time
          fraction</a>s produced by the <em>timing model</em> for a given
          <a>Anim</a> and applies it as the input to the <em>animation
          function</em> defined for the <a>Anim</a> object.
          The output of each <em>animation function</em> is then combined using
          a global animation stack before being applied to the target property
          (see <a href="#combining-animations" class="sectionRef"></a>).
        </p>
        <p>
          The entry-point to the <em>animation model</em> is the
          <a>AnimFunc</a> object associated with each <a>Anim</a>.
          These objects describe how animation values should be calculated for
          the <a>Anim</a> for any given time.
          <a>AnimFunc</a> serves as an abstract interface of which several
          concrete subclasses are provided.
        </p>
      </div>
      <section>
        <h3>The <code>AnimFunc</code> interface</h3>
        <dl title="[Constructor] interface AnimFunc" class="idl">
          <dt>attribute CompositeOperation operation</dt>
          <dd>
            <p>
              The operation used to composite this animation with the stack, as 
              specified by one of the <a>CompositeOperation</a> enumeration
              values.
            </p>
            <p>
              This value defaults to <code>"replace"</code>
            </p>
          </dd>
          <dt>attribute CompositeOperation accumulateOperation</dt>
          <dd>
            <p>
              The operation used to composite each iteration of this animation
              with the result of compositing the previous animation, as
              specified by one of the <a>CompositeOperation</a> constants
              defined in this interface.
            </p>
            <p>
              This value defaults to <code>"replace"</code>.
            </p>
          </dd>
          <dt>any sample (double? timeFraction, double currentIteration,
                          Element? target, any underlyingValue)</dt>
          <dd>
            <div class="todo">
              <p>
                Define this here?<br>
                Potentially this should be an interface that script could
                provide its own object for.
              </p>
              <p>
                Implementations of the function would be expected to produce the
                same result given the same parameters so the implementation
                could cache the result and not call the function when the
                parameters were the same. 
              </p>
              <p>
                <code>timeFraction</code> would be a number between 0.0 and 1.0
                inclusive.
                <code>null</code> values indicate the function should no longer
                affect the target.
              </p>
              <p>
                Pass in <code>isSeeking</code> as a flag?
                Tempting to pass in <code>aPreviousTimeFraction</code> but
                I think functions that need that can track it themselves?
                Although that requires a new instance of the function for each
                target.
              </p>
            </div>
          </dd>
          <dt>AnimFunc clone ()</dt>
          <dd>
            <p>
              Creates and returns a new object of the same type as this object's
              most-derived interface such that it will produce the same output
              as this object.
            </p>
            <p class="todo">
              We either need a more rigorous definition here or (probably
              better) a sets of steps on a per-subclass basis.
            </p>
          </dd>
        </dl>
        <p class="todo">
          Need to add exception behavior for this interface and all its
          subclasses for when it is linked to a template.
        </p>
      </section>
      <section>
        <h3>The <code>CompositeOperation</code> enumeration</h3>
        <dl title="enum CompositeOperation" class="idl">
          <dt>replace</dt>
          <dd>
            The animation should replace the value it is composited with.
          </dd>
          <dt>accumulate</dt>
          <dd>
            The animation should add to the value it is composited with.
            The meaning of addition is dependent on the type of animation.
          </dd>
          <dt>merge</dt>
          <dd>
            The animation should merge with the value it is composited with.
            The meaning of merge is dependent on the type of animation.
            The duration of the merge is the calculated animation duration
            of the <code>AnimTemplate</code> containing this
            <code>AnimFunc</code>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>KeyframesAnimFunc</code> interface</h3>
        <div class="todo">
          <p>
            Need to define convenience ctors here. I think you want to support
            something like this:
          </p>
          <pre class="sh_javascript">
{
  [
    { offset: 0,   height: '200px' },
    { offset: 0.2, height: '300px', timing: 'ease-in' },
    { offset: 1,   height: '400px' },
  ]
}</pre>
          <p>
            If <code>offset</code> is not specified it makes them equidistant?
            That assumes they're in order though.
          </p>
          <p>
            Also, ideally the ctor for <a>GroupedAnimFunc</a> would accept
            the above input as well as the below.
          </p>
          <pre class="sh_javascript">
{
  [
    { offset: 0, height: '200px' },
    { offset: 1, height: '400px', width: '500px' },
  ]
}</pre>
          <p>
            As a bonus, the ctor for <a>KeyframesAnimFunc</a> should also be
            nice to support the following arrangement:
          </p>
          <pre class="sh_javascript">
{
  prop: 'height',
  values: [ '200px', '300px', '400px']
}</pre>
        </div>
        <p class="todo">
          Need to define exceptions when this is a read-only object.
        </p>
        <p>
          <dl title="[Constructor] interface KeyframesAnimFunc : AnimFunc"
            class="idl">
            <dt>attribute DOMString property</dt>
            <dd>
              The target attribute / property. <code>property</code> is probably
              a reserved word we should avoid though.
            </dd>
            <dt>attribute AnimFrameList frames</dt>
            <dd>
              The series of values that make up this function sorted by their
              offset within the iteration duration of the animation.
            </dd>
          </dl>
        </p>
      </section>
      <section>
        <h3>The <code>AnimFrame</code> interface</h3>
        <p>
          <dl title="[Constructor] interface AnimFrame" class="idl">
            <dt>attribute any value</dt>
            <dd>
              The attribute / property value for the given frame
            </dd>
            <dt>attribute double offset</dt>
            <dd>
              A value between 0 and 1 (inclusive) representing the offset within
              the iteration duration of the animation where this value should
              appear. Ignored if we're using paced timing?<br>
              What happens if you change it? The array returned by the
              <code>AnimFunc</code> is updated? I guess that's fine
              if it's just an array. Any already-returned arrays wouldn't need
              to be updated.<br>
              What happens if you have two values with the same offset? It would
              be nice if the result was deterministic rather than just left up
              in the air (since the more you leave undefined, the more you let
              the Web define it for you).
            </dd>
            <dt>attribute TimingFunc timingFunc</dt>
            <dd>
              The function to use for this segment. Would a string do here? E.g.
              "ease" or "cubic-bezier(1 0 0.3 1)"? Probably not. It's a little
              too CSS-specific for a start, and we want to allow this to
              potentially be a function pointer.<br>
              Ignored if we're using paced timing
            </dd>
          </dl>
        </p>
      </section>
      <section>
        <h3>The <code>AnimFrameList</code> interface</h3>
        <dl title="interface AnimFrameList" class="idl">
          <dt>readonly attribute unsigned long length</dt>
          <dd>
            The number of frames in the list.
          </dd>
          <dt>AnimFrameList? item(unsigned long index)</dt>
          <dd>
            Returns the frame at <code>index</code> if it exists or null.
          </dd>
          <dt>AnimFrameList? add(AnimFrame frame)</dt>
          <dd>
            Adds <code>frame</code> to the list such that the list is sorted
            by the offset of the frames. If there's already a frame with the
            same offset? This one comes after?
          </dd>
          <dt>AnimFrameList? remove(unsigned long index)</dt>
          <dd>
            Adds <code>frame</code> to the list such that the list is sorted
            by the offset of the frames. If there's already a frame with the
            same offset? This one comes after?
          </dd>
        </dl>
        <p>
          Not sure about the <code>remove</code> method. Do we want:
          <ul>
            <li><code>remove(AnimFrame frame)</code>?</li>
            <li><code>removeAtOffset(unsigned long offset)</code>?</li>
            <li><code>itemAtOffset(unsigned long offset)</code>?</li>
          </ul>
        </p>
      </section>
      <section>
        <h3>The <code>PathAnimFunc</code> interface</h3>
        <dl title="[Constructor] interface PathAnimFunc : AnimFunc" class="idl">
          <dt>attribute SVGPathSegList segments</dt>
          <dd>
            The list of segments that make up this path.
          </dd>
          <dt>attribute boolean rotate</dt>
          <dd>
            True if objects animating along this path should be rotated
            such that their positive x axis is aligned with the direction of
            movement along the path.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>GroupedAnimFunc</code> interface</h3>
        <p>
          The <code>GroupedAnimFunc</code> interface represents a
          set of animation functions that share the same
          <code>AnimTemplate</code> parent.
        </p>
        <dl title="[Constructor] interface GroupedAnimFunc : AnimFunc"
          class="idl">
          <dt>readonly attribute unsigned long length</dt>
          <dd>
            The number of animation functions in the group.
          </dd>
          <dt>AnimFunc? item(unsigned long index)</dt>
          <dd>
            Returns the function at <code>index</code> if it exists, or null.
          </dd>
          <dt>void add(AnimFunc func)</dt>
          <dd>
            Adds <code>func</code> to the group.
          </dd>
          <dt>void remove(unsigned long index)</dt>
          <dd>
            Removes the function at <code>index</code> if it exists.
          </dd>
        </dl>
      </section>
      <section>
        <h3>Calculating animation values</h3>
        <section>
          <h4>Calculating the animation value from an iteration value</h4>
          <p>
            If the <a>current iteration</a> is zero, or the 
            <var>accumulateOperation</var> is
            <code>"replace"</code>, then the 
            <var>animation value</var> is simply the iteration value, as
            defined below.
          </p>
          <p>
            When the animation time equals the iteration duration for the 
            first time for an animation, the current 
            <var>animation value</var> should be retained as the
            <var>end value</var> for the animation.
          </p>
          <p class="todo">
            Need to revise this definition since we can't assume the time at
            the end of the first iteration will be visited (we might be
            playing backwards, or have a <var>iteration start</var> greater
            than 1).
          </p>
          <p>
            If the <a>current iteration</a> is not zero and the
            <var>accumulateOperation</var> is
            <code>"accumulate"</code> then the 
            <var>animation value</var> is the <var>end value</var> accumulated
            <a>current iteration</a> times, with the 
            <var>iteration value</var> accumulated on top.
          </p>
          <p>
            If the <a>current iteration</a> is not zero and the
            <var>accumulateOperation</var> is
            <code>"merge"</code> then the
            <var>animation balue</var> is the <var>end value</var> merged
            with the <var>iteration value</var>, with an interpolation
            parameter equal to the current <var>time fraction</var>
          </p>
        </section>
        <section>              
          <h4>Calculating the iteration value for a 
            <code>KeyframesAnimFunc</code></h4>
          <p>
            When an <code>AnimTemplate</code> contains a pointer to a
            <code>KeyframesAnimFunc</code> <var>keyframes</var>, the
            <var>animation value</var> for that animation at given current time
            <var>t</var> is calculated according to the following steps:
          </p>
          <ol>
            <li>
              Convert <var>t</var> to the <var>time fraction</var> 
              (see <a href="#calculating-the-time-fraction" class="sectionRef"></a>).
            </li>
            <li>
              Generate a <var>sorted frame list</var> by sorting the list of
              <code>AnimFrame</code> objects contained within the
              <code>AnimFrameList</code> object stored in <var>keyframes.frames</var> 
              by their <var>offset</var>.
              If there are no frames in the <var>sorted frame list</var>
              then no animation occurs and the <var>iteration value</var> is
              just the <var>base value</var> of the property being animated.
            </li>
            <li>
              Otherwise, find the <var>after frame</var> by iterating through
              the <var>sorted frame list</var> until the last
              <code>AnimFrame</code> with an <var>offset</var>
              larger than the <var>time fraction</var> is
              encountered.
            </li>
            <li>
              If the <var>after frame</var> is the first frame in the
              <var>sorted frame list</var>, then construct a 
              <var>before frame</var> with an <var>offset</var> of 0 and a
              value equal to the <var>base value</var> of the property being
              animated.
            </li>
            <li>
              If the <var>after frame</var> does not exist (i.e. all frames
              have an <var>offset</var> less than the <var>time 
              fraction</var>) then construct an <var>after frame</var> with
              an <var>offset</var> of 1 and a value equal to the
              <var>base value</var> of the property being animated, and
              Set the <var>before frame</var> to the last frame in the 
              <var>sorted frame list</var>.
            </li> 
            <li>
              Otherwise (the <var>after frame</var> exists and is not the
              first frame in the <var>sorted frame list</var>) set the 
              <var>before frame</var> to the frame immediately prior to the
              <var>after frame</var> in the <var>sorted frame list</var>.
            </li>
            <li>
              The <var>local time function</var> is the
              <var>timingFunc</var> of the <var>before frame</var>, if 
              it exists; otherwise the <var>timingFunc</var> of the
              <code>Anim</code> interface's <var>timing</var> attribute.
            </li>
            <li>
              Find the <var>local time fraction</var> by subtracting
              the <var>offset</var> of the <var>before frame</var> from
              the <var>time fraction</var>, then dividing the result
              by the difference between the <var>offset</var> of the
              <var>after frame</var> and the <var>offset</var> of the
              <var>before frame</var>.
            <li>
              Calculate the <var>effective time fraction</var> by applying
              the <var>local time function</var> to the <var>local time
              fraction</var>.
            <li>
              Calculate the <var>animation value</var> by linearly 
              interpolating the values of the <var>before frame</var> and
              <var>after frame</var>, using the 
              <var>effective time fraction</var> as interpolation parameter (see <a href="#linear-interpolation" class="sectionRef"></a>).
            </li>
          </ol>
        </section>
        <section>
          <h4>Calculating the iteration value for a 
            <code>PathAnimFunc</code></h4>
          <p>
            When an <code>AnimTemplate</code> contains a pointer to a
            <code>PathAnimFunc</code> and <var>rotate</var> is set
            to false, the <var>animation value</var> for that animation at
            given current time <var>t</var> is the transform defined by a
            translation equal to the location on the path at <var>t</var>.
          </p>
          <p>
            When <var>rotate</var> is set to true, the
            <var>animation value</var> is the transform defined by the above
            translation followed by a rotation defined by the following
            process:
          </p>
          <ol>
            <li>
              Calculate the <var>normal</var> to the path at <var>t</var> (see <a href="#calculating-the-normal-to-a-path" class="sectionRef"></a>).
            </li>
            <li>
              Determine the <var>normal rotation</var>, which is given by 
              <var>atan2(normal.y, normal.x).
            </li>
            <li>
              The <var>rotation</var> is the transform that rotates by
              the <var>normal rotation</var>.
            </li>
          </ol>
        </section>
        <section>
          <h4>Calculating the iteration value for a 
            <code>GroupedAnimFunc</code></h4>
          <p>
            When an <code>AnimTemplate</code> contains a pointer to a
            <code>GroupedAnimFunc</code>, the <var>animation
            value</var> for that animation at given current time <var>t</var> 
            is calculated by following the procedure outlined in
            <a href="#resolving-animation-stacks" class="sectionRef"></a>, 
            treating the list of <code>AnimFunc</code> objects 
            contained within the <code>GroupedAnimFunc</code> as 
            the animation stack and using an initial animation value 
            of 0 for all simple properties and id for transform.
          </p>
        </section>
      </section>
      <div class="todo">
        <p>
          Need to add:
          <ul>
            <li>Pre-defined timing functions, spline-based timing functions etc.
            (want to allow a series of splines, not just four points)</li>
            <li>Custom easing functions</li>
            <li>Pace control (e.g. <code>pace="10px/s"</code>?)</li>
            <li>General functional syntax</li>
            <li>&lsquo;to&rsquo; animation</li>
          </ul>
        </p>
        <p>
          Somewhere we need to describe how animated values get stored in the
          DOM. i.e. can you access them at all? what's the interaction with
          various override stylesheets etc.
        </p>
        <p>
          Need to add a way for getting animation values of motion-on-a-path
          animations
        </p>
      </div>
    </section>

    <section>
      <h2>Primitive animation operations</h2>
      <section>
        <h3>Linear interpolation</h3>
        <section>
          <h4>Linear interpolation of paths</h4>
          <p class="todo">Write me</p>
        </section>
        <section>
          <h4>Linear interpolation of transforms</h4>
          <p class="todo">Write me</p>        
        </section>
        <section>
          <h4>Linear interpolation of primitive values</h4>
          <p class="todo">Write me</p>
        </section>
      </section>
      <section>
        <h3>Calculating the normal to a path</h3>
        <p class="todo">Write me</p>
      </section>
    </section>
    <section>
      <h2>Combining animations</h2>
      <section>
        <h3>The Global Animation Stack</h3>
        <p>
          When multiple <a>in effect</a> animations target the same element, the
          animations are ordered into a stack which resolves how those 
          animations combine.
          This stack is sorted by animation <var>start time</var>.
          Where multiple animations have the same start time, those animations
          are sorted in document order (for animations from the DOM) and script
          order (for animations from the API). Script animations are always
          sorted after DOM animations.
        </p>
        <p>
          Other operations also generate animation stacks - for example, 
          grouping multiple animations using a 
          <code>GroupedAnimFunc</code>.
        </p>
        <p>
          An animation stack may be thought of as a single stack with all
          animations sorted into it, or a stack per animating element, as
          animations on one element cannot effect the course of animations on 
          another element.
        </p>
        <p class="note">
          The start time of an animation refers to the time when the animation
          is specified to begin as recorded in the
          <code>TimedItem.startTime</code> property, that is, before applying
          any <var>start delay</var>.
        </p>
        <p class="note">
          The stacking order of animations is independent of the
          current play direction of individual animations and animation
          groups.
        </p>
      </section>
      <section>
        <h3>Resolving Animation Stacks</h3>
        <p>
          In order to resolve an animation stack, an initial animation
          value is required for each element and property animated by the
          stack.
          To calculate a current animation value for elements and properties
          from an animation stack, an animation value is generated for each
          animation in the stack 
          (see <a href="#calculating-animation-values" class="sectionRef"></a>).
          The cumulative animation result for each element and property is first
          initialised to the relevant initial animation value.
          Starting at the bottom of the stack (i.e. earliest start time) and
          working up, as animation results are encountered for an element
          and property, these are merged into the cumulative animation result
          using the animation combinator stored in the 
          <code>AnimFunc</code> that generated the result.
          Once all animation results in the stack are processed, the resulting
          cumulative animation values are the current animation values for
          each property of each element that is animated.
        </p>
      </section>
      <section>
        <h3>Animation combinators</h3>
        <p>
          When an animation applies to a target and property that animations
          earlier in the animation stack have already applied to, the
          cumulative animation result from the stack is composited with the new
          animation to produce a new cumulative animation result.
          The possible combinators are defined by the <a>CompositeOperation</a>
          enumeration.
        </p>
        <section>
          <h4>The REPLACE combinator</h4>
          <p>
            When an animation <code>a</code> is composited over a cumulative
            animation result <code>c</code> using the REPLACE combinator, the
            new cumulative animation result is always <code>a</code>.
          </p>
        </section>
        <section>
          <h4>The ACCUMULATE combinator</h4>
          <p>
            When a path animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the ACCUMULATE
            combinator, the effective transform of <code>a</code> is calculated.
            This transform is then post-multiplied to the cumulative animation
            result to generate a new cumulative animation result.
          </p>
          <p>
            When a transform animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the ACCUMULATE
            combinator, <code>a</code> is post-multiplied to the cumulative
            animation result to generate a new cumulative animation result.
          </p>
          <p>
            When a simple animation (i.e. an animation which is not a path
            animation nor a transform animation) <code>a</code> is composited
            over a cumulative animation result <code>c</code> using the
            ACCUMULATE combinator, the new cumulative animation result is the
            sum of <code>a</code> and <code>c</code>, clipped if necessary to
            the appropriate domain.
          </p>
        </section>
        <section>
          <h4>The MERGE combinator</h4>
          <p>
            All MERGE operators are governed by an interpolation parameter
            <code>p</code> that is calculated as the ratio of
            <code>(currentTime - parent.startTime) / parent.animationDuration</code>,
            where <code>parent</code> is the <code>AnimTemplate</code> which
            references the <code>AnimFunc</code> that is being
            composited.
          </p>
          <p>
            When a path animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, the effective transform of <code>a</code> is
            calculated.
            This transform is then interpolated with <code>c</code> using the
            rules provided in [[!CSS3-2D-TRANSFORMS]] to provide the new
            cumulative animation result.
          </p>
          <p>
            When a transform animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, <code>a</code> is interpolated with <code>c</code>
            using the rules provide in [[!CSS3-2D-TRANSFORMS]] to provide the 
            new cumulative animation result.
          </p>
          <p>
            When a simple animation <code>a</code> is composited over a
            cumulative animation result <code>c</code> using the MERGE
            combinator, the new cumulative animation result is calculated as
            the weighted sum of <code>a</code> and <code>c</code>, with weights
            of <code>(1-p)</code> and <code>p</code> respectively.
          </p>
        </section>
      </section>
      <section>
        <h3>Current values, animation values, and the override stylesheet</h3>
        <section>
          <h4>Current values</h4>
          <p>
            The <var>current value</var> of a given property and object is the
            value generated for that property by computing a current style for
            that object without taking the override stylesheet into account.
          </p>
        </section>
        <section>
          <h4>The override stylesheet</h4>
          <p>
            The override stylesheet contains output animation values and
            acts with a higher priority than all other stylesheets. However,
            !important rules from all other stylesheets act with a higher priority
            than the override stylesheet.

            The override stylesheet is regenerated for each timepoint in a
            document using the process described below.
          </p>
        </section>
        <section>
          <h4>Animation values</h4>
          <p class="todo">
            We already have a section with the heading "animation values".
            Ideally they should be unique so they're easy to target by named
            anchor.
          </p>
          <p>
            Animation values for all animated properties are generated at
            each time point according to the following process, then inserted
            into the override stylesheet.
          </p>
          <ol>
            <li>
              A global animation stack is generated as described in 
              <a href="#the-global-animation-stack" class="sectionRef"></a>.
            </li>
            <li>
              An initial animation value is generated by taking the current
              style for each object (ignoring the override stylesheet) and
              extracting a value for each animated property.
            </li>
            <li>
              The global animation stack is resolved using the initial animation
              value and the process in 
              <a class="sectionRef" href="#resolving-animation-stacks"></a>.
            </li>
            <li>
              The current animation values generated by this process are inserted
              into the override stylesheet.
            </li>
            <p class="todo">
              Do we need to work out how to use the override stylesheet for
              elements that don't have an id but are targetted for animations?
            </p>
          </ol>
        </section>
      </section>
    </section>

    <section>
      <h2>Animation templates</h2>
      <div class="informative">
      <p>
        It is sometimes necessary to apply the same animation effect to a series
        of targets.
        Animation templates provide a means for the same set of animation
        properties to be applied repeatedly to a number of targets
        whilst maintaining a link such that changes to the template are
        reflected at each place where the template is applied.
      </p>
      <p>
        In concrete terms, an <a>AnimTemplate</a> object is used to create
        multiple <a>Anim</a> objects each of which maintains a link back to the
        template via its <code>template</code> property.
        Such <a>Anim</a> objects are said to be <dfn>linked</dfn> to a template.
      </p>
      <p>
        The timing and animation parameters of <a>linked</a> animations cannot
        be modified directly.
        Rather, changes are made to the template which is then echoed to all
        animations linked to the same template.
        In order to modify the timing and animation parameters of
        a <a>linked</a> animation directly, it must first be unlinked using the
        <code>unlink</code> method.
      </p>
      <p>
        Note that run-time properties of a <a>linked</a> animation such as its
        <var>start time</var> and <var>time drift</var> can still be modified.
        Only those properties attached to the <code>timing</code> and
        <code>func</code> properties of a <a>linked</a> <a>Anim</a> object are
        read-only.
      </p>
      <p>
        Unlinked animations can be linked to a template by:
      </p>
      <ul>
        <li>assigning the <var>template</var> property to an
        <a>AnimTemplate</a> <span class="todo">(Is this right? Are we going to
        do this?)</span>, or</li>
        <li>calling <code>templatize</code> to create a new <a>AnimTemplate</a>
        with properties set to reflect the current state of the <a>Anim</a>
        object on which it is called.</li>
      </ul>
      <p class="todo">
        Provide some javascript sample here demonstrating?
      </p>
      </div> <!-- informative -->
      <section>
        <h3>The <code>AnimTemplate</code> interface</h3>
        <p>
          <dl title="[Constructor] interface AnimTemplate : TimedTemplate"
            class="idl">
            <dt>attribute AnimFunc func</dt>
            <dd>
              The animation function to apply.
            </dd>
          </dl>
        </p>
      </section>
      <section>
        <h3>The <code>TimedTemplate</code> interface</h3>
        <p>
          Both the timing of an <code>AnimTemplate</code> and the methods for
          creating an <code>Anim</code> from
          an <code>AnimTemplate</code> are specified on the
          <code>TimedTemplate</code> since this behavior is shared with
          animation groups (see <a href="#group-templates"
          class="sectionRef"></a>).
        </p>
        <p class="todo">
          Should we allow live lists to be passed in? i.e. selectors etc.?
        </p>
        <dl title="interface TimedTemplate" class="idl">
          <dt>attribute Timing timing</dt>
          <dd>
            The timing parameters to use for generated timed items.
          </dd>
          <dt>TimedItem animate ()</dt>
          <dd>
            <p>
              Creates an independent <code>TimedItem</code> and appends it
              to <code>element.ownerDocument.animationTimeline</code>.
            </p>
            <p>
              This allows the following sort of usage:
            </p>
            <pre class="example sh_javascript">
              anim.animate(document.getElementById("a"));
            </pre>
            <p>
              The specific steps for instantiating a
              <code>TimedTemplate</code> depends on its concrete type and is
              described in <a href="#instantiating-an-animtemplate"
              class="sectionRef"></a> and <a
              href="#instantiating-an-animgrouptemplate"
              class="sectionRef"></a>.
            </p>
            <dl class="parameters">
              <dt>Element target</dt>
              <dd>
                The <code>Element</code> to be targetted.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                <p>
                  The start time for the generated animations
                  expressed in seconds in the iteration time space of the
                  <code>AnimGroup</code> to which it is
                  appended (see <a href="#time-spaces" class="sectionRef"></a>).
                </p>
                <p>
                  If this parameter is not specified it will default to the
                  current iteration time of the
                  <code>AnimGroup</code> to which it is
                  appended if it is not <code>null</code>, otherwise it will
                  default to zero.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>sequence&lt;TimedItem&gt; animate ()</dt>
          <dd>
            <p>
              Creates a series of independent <code>TimedItem</code>
              objects, one for each element in <code>target</code>.
              As with <code>animate(Element target, double startTime)</code>
              each such <code>TimedItem</code> object is appended
              to <code>element.ownerDocument.animationTimeline</code>.
            </p>
            <p>
              This allows the following sort of usage:
            </p>
            <pre class="example sh_javascript">
  anim.animate([document.getElementById("a"), document.getElementById("b")]);
  anim.animate(document.querySelectorAll("div.warning"));
  anim.animate(document.getElementsByTagName("button"));
  anim.animate(document.getElementById("group").childNodes);
            </pre>
            <p>
              The specific steps for instantiating a
              <code>TimedTemplate</code> depends on its concrete type and is
              described in <a href="#instantiating-an-animtemplate"
              class="sectionRef"></a> and <a
              href="#instantiating-an-animgrouptemplate"
              class="sectionRef"></a>.
            </p>
            <dl class="parameters">
              <dt>sequence&lt;Node&gt; targets</dt>
              <dd>
                An sequence of <code>Node</code>s to be animated.
                Any nodes in the sequence that are not of type
                <code>ELEMENT_NODE</code> will be ignored.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                As with <code>animate(Element target, optional double
                  startTime)</code>.
              </dd>
            </dl>
          </dd>
          <dt>TimedItem animateWithParent ()</dt>
          <dd>
            <p>
              Similar to <code>animate</code>, this method creates
              independent <code>TimedItem</code> object(s) for the
              elements in <code>target</code>.
              However, the resulting items are appended to the given
              <code>parentGroup</code>, if provided.
              If <code>parentGroup</code> is <code>null</code>, the
              <code>TimedItem</code> objects will not be added to any
              group.
            </p>
            <dl class="parameters">
              <dt>Element target</dt>
              <dd>
                As with <code>animate</code>.
              </dd>
              <dt>AnimGroup? parentGroup</dt>
              <dd>
                The animation group to which animations should be appended.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                <p>
                  The start time for the generated animations
                  expressed in seconds in the iteration time space of the
                  <code>AnimGroup</code> to which it is
                  appended (see <a href="#time-spaces" class="sectionRef"></a>).
                </p>
                <p>
                  If this parameter is not specified it will default to the
                  current iteration time of <code>parentGroup</code>.
                  If <code>parentGroup</code> is <code>null</code>,
                  this parameter will default to zero.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateWithParent (
            sequence&lt;Node&gt; targets,
            AnimGroup? parentGroup,
            optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent(Element target,
              AnimGroup? parentGroup,
              optional double startTime)</code> except
            one <code>TimedItem</code> is created for each
            <code>Node</code> in <code>target</code> that is of type
            <code>ELEMENT_NODE</code>.
          </dd>
          <dt>TimedItem animateLive (Element target,
            optional double startTime)</dt>
          <dd>
            As with <code>animate</code> with the exception that the
            <code>TimedItem</code> objects generated by this method are
            live.
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateLive (
            sequence&lt;Node&gt; targets, optional double startTime)</dt>
          <dd>
            As with <code>animate</code> with the exception that the
            <code>TimedItem</code> objects generated by this method are
            live.
          </dd>
          <dt>TimedItem animateLiveWithParent
            (Element target, AnimGroup? parentGroup,
             optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent</code> with the exception that the
            animations generated by this method are live.
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateLiveWithParent
            (sequence&lt;Node&gt; targets, AnimGroup? parentGroup,
             optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent</code> with the exception that the
            animations generated by this method are live.
          </dd>
        </dl>
      </section>
      <section>
        <h3>Instantiating an <code>AnimTemplate</code></h3>
        <p>
          The procedure for instantiating an <code>AnimTemplate</code>,
          <var>template</var>, given a list of target elements and an optional
          <var>parent group</var>, is as follows:
        </p>
        <ol>
          <li>
            Create an empty sequence of <code>Anim</code> objects.
          </li>
          <li>
            For each <var>element</var> in the list of target elements:
            <ol>
              <li>
                Create a new <code>Anim</code> object, <var>anim</var>.
              </li>
              <li>
                Set the <code>timing</code> and <code>func</code> properties
                of <var>anim</var> to copies <code>template.timing</code>
                and <code>template.func</code>.
              </li>
              <li>
                If <var>parentGroup</var> is not specified, let
                <var>parentGroup</var> be
                <code><var>element</var>.ownerDocument.animationTimeline</code>.
              </li>
              <li>
                Append <var>element</var> to <var>parentGroup</var>.
              </li>
              <li>
                Append <var>element</var> to the sequence of <code>Anim</code>
                objects.
              </li>
            </ol>
          </li>
          <li>
            Return the sequence of <code>Anim</code> objects.
          </li>
        </ol>
      </section>
      <section>
        <h3>Group templates</h3>
        <p>
          As with animations, templates can also be created for animation
          groups.
        </p>
        <p class="todo">
          Lots of questions here about how this should work.
        </p>
      </section>
      <section>
        <h3>The <code>AnimGroupTemplate</code> interface</h3>
        <p class="todo">
          TBD
        </p>
        <dl title="interface AnimGroupTemplate : TimedTemplate" class="idl">
          <dt>void clear ()</dt>
          <dd>
            Removes all child items from the group.
          </dd>
          <dt>getter TimedTemplate? (unsigned long index)</dt>
          <dd>
            Returns the template item at <code>index</code>.
            If <code>index</code> is greater than or equal to
            <code>length</code> returns <code>null</code>.
          </dd>
          <dt>setter TimedTemplate (unsigned long index,
                                    TimedTemplate newItem)</dt>
          <dd>
            <p>
              Replaces the item at <code>index</code> with
              <code>newItem</code> by calling
              <code>splice(index, 1, newItem)</code>.
            </p>
            <p>
              Returns <code>newItem</code>.
            </p>
            <p>
              The behavior of this method is identical to
              the equivalent setter in <code>AnimGroup</code>
              except that DOMExceptions of type HierarchyRequestError are not
              thrown.
            </p>
          </dd>
          <dt>sequence&lt;TimedTemplate&gt; add (
                TimedTemplate newItem, TimedTemplate... otherItems)</dt>
          <dd>
            <p>
              Add <code>newItem</code> and each <code>otherItems</code> as the
              last item(s) in the group by calling <code>splice(group.length, 0,
              newItem, otherItem1, ... otherItemN)</code>.
            </p>
            <p>
              Returns a sequence containing the added items:
              <code>[newItem, otherItem1, ... otherItemN]</code>.
            </p>
          </dd>
          <dt>sequence&lt;TimedTemplate&gt; remove (
                long index, optional unsigned long count = 1)</dt>
          <dd>
            <p>
              Removes the item(s) at <code>index</code> by calling
              <code>splice(index, count)</code>.
            </p>
            <p>
              Returns the removed items.
            </p>
          </dd>
          <dt>
            sequence&lt;TimedTemplate&gt; splice ()
          </dt>
          <dd>
            <p>
              Modifies the list of children of this group by first removing
              <code>deleteCount</code> items from <code>start</code> followed by
              adding <code>newItems</code> at the same point.
            </p>
            <p>
              Returns a sequence of the items removed from group during the
              removal step (regardless of whether these items were re-added
              during the addition step).
            </p>
            <p>
              As with <code>AnimGroup.slice</code> the operation of
              slice is based on <a
              href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf#page=140">ECMAScript
              5's Array.prototype.splice</a>.
            </p>
            <p>
              The operation of this method is identical to that of
              <code>AnimGroup.slice</code> with the notable difference
              that DOMExceptions of type HierarchyRequestError are not thrown
              since there is no <code>AnimGroupTemplate</code> corresponding to
              a document timeline.
            </p>
            <dl class="parameters">
              <dt>long start</dt>
              <dd>
                The index at which items should be removed and inserted.
                Negative indices represent an offset from the end of the list of
                items.
                This value is clamped to the range [-<code>length</code>,
                <code>length</code>].
              </dd>
              <dt>unsigned long deleteCount</dt>
              <dd>
                The number of items to remove from the group beginning at
                <code>start</code>.
                Negative values are clamped to zero, and all other values are
                clamped such that
                0 &lt; <code>start</code> + <code>deleteCount</code> &le;
                length.
              </dd>
              <dt>sequence&lt;TimedTemplate&gt; newItems</dt>
              <dd>
                The items to be added at <code>start</code>.
                Each item, if it already has a parent group (including this
                group), is first removed from its parent group before being
                added to this group.
              </dd>
            </dl>
          </dd>
          <dt>
            sequence&lt;TimedTemplate&gt; splice (long start,
              unsigned long deleteCount, TimedTemplate... newItem)
          </dt>
          <dd>
            An overload of <code>splice</code> to take a variadic list of items
            rather than requiring a sequence.
            The operation is identical to <code>splice(unsigned long start,
            unsigned long deleteCount, sequence&lt;TimedTemplate&gt;
            newItems)</code>.
          </dd>
          <dt>long indexOf (TimedTemplate item)</dt>
          <dd>
            Returns the index of <code>item</code> within the group.
            If <code>item</code> is not in the group, returns <code>-1</code>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>ParAnimGroupTemplate</code> interface</h3>
        <p>
          <a>ParAnimGroup</a> objects can be created from
          <a>ParAnimGroupTemplate</a> objects.
        </p>
        <dl title="[Constructor] interface ParAnimGroupTemplate
          : AnimGroupTemplate"
          class="idl">
        </dl>
      </section>
      <section>
        <h3>The <code>SeqAnimGroupTemplate</code> interface</h3>
        <p>
          <a>SeqAnimGroup</a> objects can be created from
          <a>SeqAnimGroupTemplate</a> objects.
        </p>
        <dl title="[Constructor] interface SeqAnimGroupTemplate
          : AnimGroupTemplate"
          class="idl">
        </dl>
      </section>
      <section>
        <h3>Instantiating an <code>AnimGroupTemplate</code></h3>
        <p class="todo">
          TBD. This is probably all wrong.
        </p>
        <p>
          The procedure for creating an <code>AnimGroup</code> from
          an <code>AnimGroupTemplate</code>, <var>template</var>,
          given a list of target elements, and optionally given a <var>parent
          group</var> follows.
        </p>
        <p>
          Note that <code>ParAnimGroupTemplate</code> objects produce
          <code>ParAnimGroup</code> objects and likewise 
          <code>SeqAnimGroupTemplate</code> objects produce
          <code>SeqAnimGroup</code> objects.
          In the following description the <code>AnimGroupTemplate</code> and
          <code>AnimGroup</code> types should be substituted with the
          concrete types in use.
        </p>
        <ol>
          <li>
            Create an empty sequence to hold the generated
            <code>AnimGroup</code> objects.
          </li>
          <li>
            For each <var>element</var> in the list of target elements:
            <ol>
              <li>
                Create a new <code>AnimGroup</code> object,
                <var>group</var>.
              </li>
              <li>
                Set the <code>timing</code> property of <var>group</var> to
                a copy of <code>template.timing</code>.
              </li>
              <li>
                For each <var>child</var> in <var>template</var>, call
                <code><var>child</var>.animateWithParent(<var>element</var>,
                <var>group</var>, <code>startTime</code>)</code> or
                <code><var>child</var>.animateLiveWithParent(<var>element</var>,
                <var>group</var>, <code>startTime</code>)</code> depending on
                whether this procedure was invoked with <code>animate</code> or
                <code>animateLive</code>.
              </li>
              <li>
                If <var>parentGroup</var> is not specified, let
                <var>parentGroup</var> be
                <code><var>element</var>.ownerDocument.animationTimeline</code>.
              </li>
              <li>
                Append <var>group</var> to <var>parentGroup</var>.
              </li>
              <li>
                Append <var>group</var> to the sequence of
                <code>AnimGroup</code> objects.
              </li>
            </ol>
          </li>
          <li>
            Return the sequence of <code>AnimGroup</code> objects.
          </li>
        </ol>
      </section>
    </section>

    <section>
      <h2>Synchronizing with media</h2>
      <div class="todo">
        Currently investigating integration with HTML5's MediaController object.
      </div>
      <section>
        <h3>The <code>MediaItem</code> interface</h3>
        <dl title="interface MediaItem : TimedItem" class="idl">
          <dt>attribute HTMLMediaElement element</dt>
          <dd>
            A pointer to the element?
          </dd>
        </dl>
      </section>
    </section>

    <section>
      <h2>Animation events</h2>
      <div class="todo">
        <p>
          Need to consider how to align with existing
          <code>TransitionEvent</code>s, <code>AnimationEvent</code>s and
          <code>TimeEvent</code>s. It might make sense to have our events
          inherit from one or more of these interfaces or have implementations
          dispatch both (especially if their synchronization properties differ).
        </p>
        <p>
          I think we might also want a seek event? It seems like a lot of
          applications will want to do bookkeeping when there's
          a seek&mdash;especially a backwards seek. It might also be necessary
          for the SVG bindings so you can clear certain events on a backwards
          seek as required by SMIL.
        </p>
        <p>
          Talk about what events are dispatched on a seek.
          It's probably important that we don't dispatch intermediate events
          during a seek as then implementations will be required to step through
          each interval and it breaks the fact that skipping around the model is
          constant time.
          It's also not what SVG does, i.e. SVG skips events during a seek.
          I think you just want to record the animating vs non-animating state
          of each item before the seek, then compare to after the seek and fire
          the appropriate event.
          (Do groups fire events?)
        </p>
      </div>
      <section>
        <h3>Synchronizing event handlers</h3>
        <div class="todo">
          <p>
            The proposal to-date is as follows.
            Requirements for dispatch of animation events:
          </p>
          <ol>
            <li>
              Animations triggered by an event handler appear to have started at
              the time the event was scheduled to be triggered.
            </li>
            <li>
              No effect of an animation for any time 't' can be reflected in
              style, DOM or animation object until any animation event handlers
              associated with dispatch times at or before 't' have returned from
              execution.
            </li>
          </ol>
          <p>In effect this is roughly the same as saying:</p>
          <blockquote>
            When event handlers due to  animation events run, the state of the
            world (DOM properties etc.) so  far as it is influenced by
            animation, is as if the current time was the time when the event was
            scheduled to be triggered.
          </blockquote>
          <p>
            There may be many ways to realise this, including:
          </p>
          <ul>
            <li>
              dispatching animation events synchronously
            </li>
            <li>
              careful updating of the animation time (after waiting for
              corresponding animation events to return)
            </li>
            <li>
              pausing the world
            </li>
          </ul>
          <p>
            Shane and Tab feel that this approach is not very webby, and might
            be going to too much effort in order to support a programming
            model that should be discouraged.
          </p>
          <p>
            In the current model, the animation timeline is essentially
            static unless modified by script, which means that interrogating
            this timeline for information should be safe even in the absence
            of enforced synchronization.
            So if correct handling of an event requires precise knowledge
            about which animations have started or finished, then the timeline
            can be inspected at the time given in the event. 
          </p>
          <p>
            Furthermore, triggering animations off complex functions involving
            current animation state is probably not the right way to go - 
            instead some kind of model of the state should be used and the
            animations derived from that.
          </p>
          <p>
            In short, in the absence of strong use cases for synchronous events
            we feel we should go with a simpler model.
          </p>
          <p>
            Some alternative approaches are:
          </p>
          <ul>
            <li>
              Standard asynchronous events with no guarantees about the
              state of the world when event handlers are called.
            </li>
            <li>
              Event logs like those proposed to replace DOM events.
            </li>
        </div>
      </section>
    </section>

    <section>
      <h2>Animation of common data types</h2>
      <p>
        Need to describe how to interpolate/add both:
        <ol>
          <li>Integers, floats, strings etc.</li>
          <li>CSS and SVG types (colors etc.)</li>
          <ul><li>Support for HSL (if the colors are specified in HSL we should
            interpolate in that notation; but it should also be possible to
            do so regardless of how the colors are specified)</li></ul>
        </ol>
      </p>
      <p>
        For transforms I think it's defined elsewhere so we can either just
        point to that spec, or just refer to the fact that other specs should
        define how their types should be supported (or not) for animation.
      </p>
      <p>
        Need to provide facility for smooth interpolation of arbitrary paths.
      </p>
    </section>

    <section>
      <h2>Integration with Media Fragments</h2>
      <p>
        The Media Fragments specification [[MEDIA-FRAGMENTS]] defines a means
        for addressing a temporal range of a media resource.  For resources
        containing content animated with Web Animations the application of the
        temporal parameters is as follows:
      </p>
      <ol>
        <li>
          <p>
            If a begin time is specified, perform a seek on the document
            timeline passing in the specified begin time as the seek time (see
            <a href="#seeking-a-timed-item" class="sectionRef"></a>).
          </p>
          <p class="note">
            Note that seeking behavior is well-defined even when the document
            has yet to start and hence the seek can be performed regardless of
            the setting of the <code>timelineStart</code> property (see <a
            href="#start-of-the-timeline" class="sectionRef"></a>).
          </p>
        </li>
        <li class="todo">
          If an end time is specified... we need a way to say, "play this
          range", or "stop at this point" but in such a way that you can still
          seek beyond that range.
          (In order to be consistent with how hyperlinks work elsewhere such as
          document anchors, svg views, etc.)
          Perhaps we just make it an interal thing for now and in a future
          version add some means of playing a range, or better still, a series
          of ranges; something compatible with what we have for video.
        </li>
      </ol>
    </section>

    <section>
      <h2>Interaction with page display</h2>
      <p class="todo">
        What should be the behavior here? Should we pause on unload/pagehide?
        What does video do?
      </p>
    </section>

    <section>
      <h2>Implementation requirements</h2>
      <section>
        <h3>Discarding past animations</h3>
        <p>
          If implementations are required to preserve all state associated with
          animations then the resources required by an animation could continue
          to increase without limit over time. For long-running animations, and
          particularly those where animations are added dynamically, this could
          lead to degraded performance and eventual failure.
        </p>
        <div class="issue">
          <p>
            I'm not sure how to define this. We could say all animations with
            <code><var>end time converted to document time</var> &lt;
            <var>current document time</var> - 5min</code> can be discarded.
          </p>
          <p>
            That's fine, but what about crazy documents that put 1 million
            animations in a 5min span? Just leave that up to the browser.
            Also, what about mobile clients, is 5 min too long? Is this too
            prescriptive?
          </p>
          <p>
            Maybe, just make some suggestions (e.g. 1 min for mobile clients,
            5 min for desktop?) and then define an exception to throw if there
            is a seek to some time outside that window.
          </p>
          <p>
            Also, note that defining this in terms of past intervals is
            direction-specific but that's probably ok since most long-running
            animations will run forwards.
          </p>
        </div>
      </section>
    </section>

    <section>
      <h2>Making animation accessible</h2>
      <p class="todo">
        TBD. Describe how to integrate with the <a
          href="http://www.whatwg.org/specs/web-apps/current-work/#timed-text-tracks">Timed
          Text API</a> and give examples of how to author content so it is
        accessible.
      </p>
    </section>
    <section class='appendix'>
      <h2>Acknowledgements</h2>
    </section>
  </body>
</html>
