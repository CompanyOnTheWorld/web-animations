<!DOCTYPE html>
<!-- vim: set expandtab ts=2 sw=2 tw=80: -->
<html>
  <head>
    <title>Web Animations Future</title>
    <meta charset="utf-8">
    <script src="respec/respec.js" class="remove"></script>
    <script
      src="http://dev.w3.org/2009/dap/ReSpec.js/js/lang/sh_javascript.min.js"
      class="remove"></script>
    <script class="remove">
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use
        // ED.
        specStatus: "unofficial",

        // the specification's short name, as in
        // http://www.w3.org/TR/short-name/
        // shortName:            "web-anim",

        // if your specification has a subtitle that goes below the main
        // formal title, define it here
        // subtitle   :  "an excellent document",

        // if you wish the publication date to be other than today, set this
        // publishDate:  "2009-08-06",

        // if the specification's copyright date is a range of years, specify
        // the start date here:
        // copyrightStart: "2012"

        // if there is a previously published draft, uncomment this and set
        // its YYYY-MM-DD date and its maturity status
        // previousPublishDate: "1977-03-15",
        // previousMaturity: "WD",

        // if there a publicly available Editor's Draft, this is the link
        // edDraftURI:
        // "https://dvcs.w3.org/hg/FXTF/raw-file/tip/web-anim/index.html",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // if you want to have extra CSS, append them to this list
        // it is recommended that the respec.css stylesheet be kept
        extraCSS: ["respec/respec.css",
                   "web-animations.css"],

        // Turning off inlineCSS for now since if extraCSS points to
        // a relative URL your testing from a file URL the XHR will fail.
        // Probably should turn this back on once this is hosted on a server
        // somewhere.
        inlineCSS: false,

        // editors, add as many as you like
        // only "name" is required
        editors:  [
          { name: "Web Animations editors" }
        ],

        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.

        //authors:  [
        //    { name: "Your Name", url: "http://example.org/",
        //      company: "Your Company", companyURL: "http://example.com/" },
        //],

        // XXX If we continue using ReSpec then we need to tweak it to support
        // multiple working groups. It includes updating the patent section
        // prose to say "groups" instead of "group" etc.
        // name of the WG
        wg: "CSS Working Group (part of the Style Activity) and the SVG " +
            "Working Group (part of the Graphics Activity)",

        // URI of the public WG page
        // wgURI: "http://www.w3.org/Graphics/fx/",

        // name (without the @w3c.org) of the public mailing to which comments
        // are due
        wgPublicList: "public-fx",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI
        // from a random document unless you know what you're doing. If in
        // doubt ask your friendly neighbourhood Team Contact.
        wgPatentURI:  "",

        noIDLSorting: true,
        noIDLIn: true
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      This is the abstract for your specification.
    </section>
    <section>
      <h2>The <code>Timeline</code> interface</h2>
      <dl title="partial interface Timeline" class="idl">
        <dt>double? fromTimelineTime (double timelineTime,
                                      TimedItem target)</dt>
        <dd>
          <p class="annotation">
            This is basically supposed to be a method that answers the question,
            "If the time of this timeline is A (<em>timelineTime</em>), what
            will the local time be at timed item B (<em>target</em>)?"
          </p>
          <p>
            Returns the corresponding time value for a given timed item,
            <em>target</em>, for a time value relative to this timeline
            using the following procedure.
          </p>
          <p class="todo">
            All the following needs to be updated since it refers to time
            sources etc.
          </p>
          <ol>
            <li>Define the <dfn>parent time source</dfn> of time source A as
                being the value of a <code>timeline</code> property on A if
                such a property exists and refers to a <a>TimeSource</a>
                object.</li>
            <li>Define an <dfn>ancestor time source</dfn> of time source A as
                any time source that appears in the chain of parent time
                sources constructed starting with the <a>parent time
                source</a> of A and continuing with each subsequent parent
                up to and including a document time source or until there are
                no further parent time sources.</li>
            <li>Define a time source A as being <dfn>derived from another time
                source</dfn> B if B is an <a>ancestor time source</a> of
                A.</li>
            <li>Determine <var>local document time</var> as follows:
              <dl class="switch">
                <dt>If <em>other</em> is not <a title="derived from another
                time source">derived from</a> this document time source,</dt>
                <dd>
                  <ol>
                    <li>
                      Let <var>remote document</var> be the document time
                      source that is an <a>ancestor time source</a> of
                      <em>other</em> if such a document time source exists.
                    </li>
                    <li>
                      If there is no such <var>remote document</var> raise
                      a <code>DOMException</code> of type
                      <code>HierarchyRequestError</code>.
                    </li>
                    <li>
                      Let <var>local document time</var> be the result of
                      calling <code>toDocumentTime(<em>documentTime</em>,
                      <var>remote document</var>)</code> on this object.
                    </li>
                  </ol>
                </dd>
                <dt>Otherwise,</dt>
                <dd>
                  Let <var>local document time</var> be <em>documentTime</em>.
                </dd>
              </dl>
            </li>
            <li>
              Calculate the <code>currentTime</code> of <em>other</em> by
              following the steps described <span
              class="todo">somewhere...</span>
            </li>
          </ol>
          <p>
            Exceptions:
          </p>
          <dl class="exceptions">
            <dt>DOMException of type <code>HierarchyRequestError</code></dt>
            <dd>
              Raised if <em>other</em> does not have an <a>ancestor time
              source</a> that is a document time source object.
            </dd>
          </dl>
          <p class="issue">
            Is this needed? And is the automatic cross-document time source
            negotation required?
          </p>
        </dd>
      </dl>
    </section>
    <section>
      <h2>Scaling the time</h2>
      <section>
        <h3>The <code>TimingFunctionCallback</code> callback</h3>
        <p>
          In addition to the timing functions provided by Web Animations,
          authors may also provide their own time scaling function.
          The behavior of this function is defined by the
          <a>TimingFunctionCallback</a> type below.
        </p>
        <div title="callback TimingFunctionCallback = double ()" class="idl">
          <p>
            A <a>TimingFunctionCallback</a> function has the same behavior as
            defined for the <code>scaleTime</code> method on the
            <a>TimingFunction</a> interface.
            That is, it takes an input time fraction, applies some scaling
            operation to it, and returns an output time fraction.
          </p>
          <p>
            For the same input <code>time</code> and <code>item</code>, this
            function MUST return the same output.
          </p>
          <p>
            As a result, a user agent MAY cache the results returned by
            a <a>TimingFunctionCallback</a> as an optimization.
            Note, however, that if the <code>item</code> object is changed, this
            consitutes different input to the function and hence the user agent
            MUST NOT cache the results of the callback if the <code>item</code>
            object changes.
            Given the requirement that callback functions do not change
            <code>item</code>, a user agent can expect that it is safe to cache
            the output of a <a>TimingFunctionCallback</a> for at least the
            duration of a sample.
          </p>
          <div class="issue">
            <p>
              Is it important to be able to differentiate between when the
              scaling is being applied to an iteration as a whole or simply to
              a segment of a keyframe animation?
            </p>
            <p>
              I suspect it probably is and that that would consitute different
              input to the function.
            </p>
          </div>
          <dl class="parameters">
            <dt>double time</dt>
            <dd>
              The input time fraction in the range [0.0, 1.0].
            </dd>
            <dt>TimedItem? item</dt>
            <dd>
              The <a>TimedItem</a> for which the scaling is being performed.
              This object MUST NOT be modified.
            </dd>
          </dl>
        </div>
        <section>
          <h4>Applying time manipulations</h4>
          <p>Needs to be adjusted as follows:</p>
          <ol>
            <li>&hellip;</li>
            <li>
              Scale the time as follows:
              <dl class="switch">
                <dt>If <var>timing.timingFunction</var> is
                    a <a>TimingFunction</a> object,</dt>
                <dd>
                  <p>
                    Let <var>scaled iteration time</var> be
                    <code>unscaled iteration time *
                      timing.timingFunction.scaleTime(<var>unscaled iteration
                      time</var> / <a>iteration duration</a>)))</code>.
                  </p>
                </dd>
                <dt>If <var>timing.timingFunction</var> is
                    a <a>TimingFunctionCallback</a> function,</dt>
                <dd>
                  <p>
                    Let <var>scaled iteration time</var> be
                    <code>unscaled iteration time *
                      timing.timingFunction(<var>unscaled iteration
                      time</var> / <a>iteration duration</a>)))</code>.
                  </p>
                  <p>
                    If calling <code>timing.timingFunction</code>
                    results in an exception being thrown, let <var>scaled
                    iteration time</var> be <var>unscaled iteration time</var>.
                  </p>
                  <div class="todo">
                    <p>
                      Need to consider:
                    </p>
                    <ul>
                      <li>Is there any way to lock down the model during this
                          step? i.e. make everything read-only?
                          (Of course it's not fully possible, but can we do
                          enough that it's meaningful?)
                          Maybe implementations can just display something in
                          the console: "If you're changing stuff in a timing
                          function you're going to have a bad time"</li>
                      <li>Can we cache some values before calling to ensure that
                          at least this procedure will complete as
                          expected?</li>
                      <li>Need to define exactly when this procedure is
                          performed since both the timing and the number of
                          times it is called could produce different results if
                          the script has side effects.
                          For example, does querying
                          <code>TimedItem.iterationTime</code> result in the
                          script being executed every time?
                          <p>
                          Possibly could define things such that iteration time
                          is evaluated on each sample (need to define sampling)
                          and then only if <code>iterationTime</code> is
                          explicitly requested (i.e. no caching there)... what
                          about other operations that rely on iteration time
                          being up to date? what are they?
                          </p>
                      </li>
                      <li>At points where this is called we need to check the
                          state of the model after calling.</li>
                      <li>Do we need some disclaimer saying, "if the script has
                          side effects all bets are off"</li>
                      <li>Also need to be careful that the callback doesn't call
                          anything that triggers calculating the iteration time
                          (e.g. <code>TimedItem.iterationTime</code> should use
                          a cached value in that case)</li>
                      <li>I think script-defined timing functions might get
                          punted to v2</li>
                    </ul>
                  </div>
                </dd>
                <dt>Otherwise,</dt>
                <dd>
                  Let <var>scaled iteration time</var> be <var>unscaled
                  iteration time</var>.
                </dd>
              </dl>
            </li>
            <li>&hellip;</li>
          </ol>
        </section>
      </section>
    </section>

    <section>
      <h2>Animation templates</h2>
      <div class="informative">
      <p>
        It is sometimes necessary to apply the same animation effect to a series
        of targets.
        Animation templates provide a means for the same set of animation
        properties to be applied repeatedly to a number of targets
        whilst maintaining a link such that changes to the template are
        reflected at each place where the template is applied.
      </p>
      <p>
        In concrete terms, an <a>AnimationTemplate</a> object is used to create
        multiple <a>Animation</a> objects each of which maintains a link back to
        the template via its <code>template</code> property.
        Such <a>Animation</a> objects are said to be <dfn>linked</dfn> to
        a template.
      </p>
      <p>
        The timing and animation parameters of <a>linked</a> animations cannot
        be modified directly.
        Rather, changes are made to the template which is then echoed to all
        animations linked to the same template.
        In order to modify the timing and animation parameters of
        a <a>linked</a> animation directly, it must first be unlinked using the
        <code>unlink</code> method.
      </p>
      <p>
        Note that run-time properties of a <a>linked</a> animation such as its
        <var>start time</var> and <var>time drift</var> can still be modified.
        Only those properties attached to the <code>timing</code> and
        <code>effect</code> properties of a <a>linked</a> <a>Animation</a>
        object are read-only.
      </p>
      <p>
        Unlinked animations can be linked to a template by:
      </p>
      <ul>
        <li>assigning the <var>template</var> property to an
        <a>AnimationTemplate</a> <span class="todo">(Is this right? Are we going
        to do this?)</span>, or</li>
        <li>calling <code>templatize</code> to create a new
        <a>AnimationTemplate</a> with properties set to reflect the current
        state of the <a>Animation</a> object on which it is called.</li>
      </ul>
      <p class="todo">
        Provide some javascript sample here demonstrating?
      </p>
      </div> <!-- informative -->
      <section>
        <h3><a>Animation</a> interface members</h3>
        <dl title="partial interface Animation" class="idl">
          <dt>attribute AnimationTemplate? template</dt>
          <dd>
            <p>
              For linked animations (see <a href="#animation-templates"
              class="sectionRef"></a>), the <a>AnimationTemplate</a> object
              from which this object derives its values.
              For animations that are not linked to a template, this property is
              <code>null</code>.
            </p>
            <p>
              Setting this property has the following effect:
            </p>
            <ol>
              <li>Let <var>new template</var> be the value to assign to the
                  <code>template</code> property.</li>
              <li>If <var>new template</var> is <code>null</code>,
                <ol>
                  <li>Call <code>unlink()</code>.</li>
                </ol>
              </li>
              <li>Otherwise,
                <ol>
                  <li>Set <code>timing</code> to <code><var>new
                      template</var>.timing.clone()</code>.</li>
                  <li>Set <code>effect</code> to <code><var>new
                      template</var>.effect.clone()</code>.</li>
                  <li>Set <code>template</code> to <code><var>new
                      template</var></code>.</li>
                </ol>
              </li>
            </ol>
          </dd>
          <dt>AnimationTemplate templatize()</dt>
          <dd>
            <p>
              If this object is not already linked to a template,
              creates a new <a>AnimationTemplate</a> object based on this object
              and links this object to it (see <a href="#animation-templates"
              class="sectionRef"></a>).
            </p>
            <p class="feedbackWanted">
              What is the more useful behavior? To always create a template?
              Or to only create one if it doesn't already have one?
            </p>
            <p>
              The effect is equivalent to the following steps:
            </p>
            <ol>
              <li>Let <var>source</var> be the object on which
                  <code>templatize</code> is called.</li>
              <li>If <code><var>source</var>.template</code> is not
                  <code>null</code>, return.</li>
              <li>Create a new <a>AnimationTemplate</a> object,
                  <var>template</var>.</li>
              <li>Set <code><var>template</var>.timing</code> to
                  <code><var>source</var>.timing.clone()</code>.</li>
              <li>Set <code><var>template</var>.effect</code> to
                  <code><var>source</var>.effect.clone()</code>.</li>
              <li>Set <code><var>source</var>.template</code> to
                  <var>template</var>.</li>
              <li>Return <var>template</var>.</li>
            </ol>
          </dd>
          <dt>AnimationTemplate? unlink()</dt>
          <dd>
            <p>
              Makes this animation independent of the template with which it is
              associated if any
              (see <a href="#animation-templates" class="sectionRef"></a>)
            </p>
            <p>
              After setting <code>template</code> to <code>null</code> the
              previous value of <code>template</code> is returned.
            </p>
            <p>
              The effect is equivalent to the following steps:
            </p>
            <ol>
              <li>If <code>template</code> is <code>null</code>, return
                  <code>null</code>.</li>
              <li>Let <var>old template</var> be <code>template</code>.</li>
              <li>Set <code>timing</code> to
                  <code>template.timing.clone()</code>.</li>
              <li>Set <code>effect</code> to
                  <code>template.effect.clone()</code>.</li>
              <li>Set <code>template</code> to <code>null</code> (but do not
                  recursively call this function).</li>
              <li>Return <var>old template</var>.</li>
            </ol>
          </dd>
        </dl>
        </dl>
      </section>
      <section>
        <h3>The <code>AnimationTemplate</code> interface</h3>
        <p>
          <dl title="[Constructor] interface AnimationTemplate : TimedTemplate"
            class="idl">
            <dt>attribute (AnimationEffect or CustomAnimationEffect)
              effect</dt> <dd>
              The animation effect to apply.
            </dd>
          </dl>
        </p>
      </section>
      <section>
        <h3>The <code>TimedTemplate</code> interface</h3>
        <p>
          Both the timing of an <code>AnimationTemplate</code> and the methods
          for creating an <code>Animation</code> from an
          <code>AnimationTemplate</code> are specified on the
          <code>TimedTemplate</code> since this behavior is shared with
          animation groups (see <a href="#group-templates"
          class="sectionRef"></a>).
        </p>
        <p class="todo">
          Should we allow live lists to be passed in? i.e. selectors etc.?
        </p>
        <dl title="interface TimedTemplate" class="idl">
          <dt>attribute Timing timing</dt>
          <dd>
            The timing parameters to use for generated timed items.
          </dd>
          <dt>TimedItem animate ()</dt>
          <dd>
            <p>
              Creates an independent <code>TimedItem</code> and appends it
              to <code>element.ownerDocument.animationTimeline</code>.
            </p>
            <p>
              This allows the following sort of usage:
            </p>
            <pre class="example sh_javascript">
              anim.animate(document.getElementById("a"));
            </pre>
            <p>
              The specific steps for instantiating a
              <code>TimedTemplate</code> depends on its concrete type and is
              described in <a href="#instantiating-an-animationtemplate"
              class="sectionRef"></a> and <a
              href="#instantiating-an-animationgrouptemplate"
              class="sectionRef"></a>.
            </p>
            <dl class="parameters">
              <dt>AnimationTarget target</dt>
              <dd>
                The element or pseudo-element to be targetted.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                <p>
                  The start time for the generated animations
                  expressed in seconds in the iteration time space of the
                  <code>AnimationGroup</code> to which it is
                  appended (see <a href="#time-spaces" class="sectionRef"></a>).
                </p>
                <p>
                  If this parameter is not specified it will default to the
                  current iteration time of the
                  <code>AnimationGroup</code> to which it is
                  appended if it is not <code>null</code>, otherwise it will
                  default to zero.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>sequence&lt;TimedItem&gt; animate ()</dt>
          <dd>
            <p>
              Creates a series of independent <code>TimedItem</code>
              objects, one for each element in <code>target</code>.
              As with <code>animate(AnimationTarget target, double
              startTime)</code> each such <code>TimedItem</code> object is
              appended to <code>element.ownerDocument.animationTimeline</code>.
            </p>
            <p>
              This allows the following sort of usage:
            </p>
            <pre class="example sh_javascript">
  anim.animate([document.getElementById("a"), document.getElementById("b")]);
  anim.animate(document.querySelectorAll("div.warning"));
  anim.animate(document.getElementsByTagName("button"));
  anim.animate(document.getElementById("group").childNodes);
            </pre>
            <p>
              The specific steps for instantiating a
              <code>TimedTemplate</code> depends on its concrete type and is
              described in <a href="#instantiating-an-animationtemplate"
              class="sectionRef"></a> and <a
              href="#instantiating-an-animationgrouptemplate"
              class="sectionRef"></a>.
            </p>
            <dl class="parameters">
              <dt>sequence&lt;Node&gt; targets</dt>
              <dd>
                An sequence of <code>Node</code>s to be animated.
                Any nodes in the sequence that are not of type
                <code>ELEMENT_NODE</code> will be ignored.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                As with <code>animate(AnimationTarget target, optional double
                  startTime)</code>.
              </dd>
            </dl>
          </dd>
          <dt>TimedItem animateWithParent ()</dt>
          <dd>
            <p>
              Similar to <code>animate</code>, this method creates
              independent <code>TimedItem</code> object(s) for the
              elements in <code>target</code>.
              However, the resulting items are appended to the given
              <code>parentGroup</code>, if provided.
              If <code>parentGroup</code> is <code>null</code>, the
              <code>TimedItem</code> objects will not be added to any
              group.
            </p>
            <dl class="parameters">
              <dt>AnimationTarget target</dt>
              <dd>
                As with <code>animate</code>.
              </dd>
              <dt>AnimationGroup? parentGroup</dt>
              <dd>
                The animation group to which animations should be appended.
              </dd>
              <dt>optional double startTime</dt>
              <dd>
                <p>
                  The start time for the generated animations
                  expressed in seconds in the iteration time space of the
                  <code>AnimationGroup</code> to which it is
                  appended (see <a href="#time-spaces" class="sectionRef"></a>).
                </p>
                <p>
                  If this parameter is not specified it will default to the
                  current iteration time of <code>parentGroup</code>.
                  If <code>parentGroup</code> is <code>null</code>,
                  this parameter will default to zero.
                </p>
              </dd>
            </dl>
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateWithParent (
            sequence&lt;Node&gt; targets,
            AnimationGroup? parentGroup,
            optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent(AnimationTarget target,
              AnimationGroup? parentGroup,
              optional double startTime)</code> except
            one <code>TimedItem</code> is created for each
            <code>Node</code> in <code>target</code> that is of type
            <code>ELEMENT_NODE</code>.
          </dd>
          <dt>TimedItem animateLive (AnimationTarget target,
            optional double startTime)</dt>
          <dd>
            As with <code>animate</code> with the exception that the
            <code>TimedItem</code> objects generated by this method are
            live.
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateLive (
            sequence&lt;Node&gt; targets, optional double startTime)</dt>
          <dd>
            As with <code>animate</code> with the exception that the
            <code>TimedItem</code> objects generated by this method are
            live.
          </dd>
          <dt>TimedItem animateLiveWithParent
            (AnimationTarget target, AnimationGroup? parentGroup,
             optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent</code> with the exception that the
            animations generated by this method are live.
          </dd>
          <dt>sequence&lt;TimedItem&gt; animateLiveWithParent
            (sequence&lt;Node&gt; targets, AnimationGroup? parentGroup,
             optional double startTime)</dt>
          <dd>
            As with <code>animateWithParent</code> with the exception that the
            animations generated by this method are live.
          </dd>
        </dl>
      </section>
      <section>
        <h3>Instantiating an <code>AnimationTemplate</code></h3>
        <p>
          The procedure for instantiating an <code>AnimationTemplate</code>,
          <var>template</var>, given a list of target elements and an optional
          <var>parent group</var>, is as follows:
        </p>
        <ol>
          <li>
            Create an empty sequence of <code>Animation</code> objects.
          </li>
          <li>
            For each <var>element</var> in the list of target elements:
            <ol>
              <li>
                Create a new <code>Animation</code> object, <var>anim</var>.
              </li>
              <li>
                Set the <code>timing</code> and <code>effect</code>
                properties of <var>anim</var> to copies
                <code>template.timing</code> and
                <code>template.effect</code>.
              </li>
              <li>
                If <var>parentGroup</var> is not specified, let
                <var>parentGroup</var> be
                <code><var>element</var>.ownerDocument.animationTimeline</code>.
              </li>
              <li>
                Append <var>element</var> to <var>parentGroup</var>.
              </li>
              <li>
                Append <var>element</var> to the sequence of
                <code>Animation</code> objects.
              </li>
            </ol>
          </li>
          <li>
            Return the sequence of <code>Animation</code> objects.
          </li>
        </ol>
      </section>
      <section>
        <h3>Group templates</h3>
        <p>
          As with animations, templates can also be created for animation
          groups.
        </p>
        <p class="todo">
          Lots of questions here about how this should work.
        </p>
      </section>
      <section>
        <h3>The <code>AnimationGroupTemplate</code> interface</h3>
        <p class="todo">
          TBD
        </p>
        <dl title="interface AnimationGroupTemplate : TimedTemplate"
          class="idl">
          <dt>void clear ()</dt>
          <dd>
            Removes all child items from the group.
          </dd>
          <dt>getter TimedTemplate? (unsigned long index)</dt>
          <dd>
            Returns the template item at <code>index</code>.
            If <code>index</code> is greater than or equal to
            <code>length</code> returns <code>null</code>.
          </dd>
          <dt>setter TimedTemplate (unsigned long index,
                                    TimedTemplate newItem)</dt>
          <dd>
            <p>
              Replaces the item at <code>index</code> with
              <code>newItem</code> by calling
              <code>splice(index, 1, newItem)</code>.
            </p>
            <p>
              Returns <code>newItem</code>.
            </p>
            <p>
              The behavior of this method is identical to
              the equivalent setter in <code>AnimationGroup</code>
              except that DOMExceptions of type HierarchyRequestError are not
              thrown.
            </p>
          </dd>
          <dt>sequence&lt;TimedTemplate&gt; add (
                TimedTemplate newItem, TimedTemplate... otherItems)</dt>
          <dd>
            <p>
              Add <code>newItem</code> and each <code>otherItems</code> as the
              last item(s) in the group by calling <code>splice(group.length, 0,
              newItem, otherItem1, ... otherItemN)</code>.
            </p>
            <p>
              Returns a sequence containing the added items:
              <code>[newItem, otherItem1, ... otherItemN]</code>.
            </p>
          </dd>
          <dt>sequence&lt;TimedTemplate&gt; remove (
                long index, optional unsigned long count = 1)</dt>
          <dd>
            <p>
              Removes the item(s) at <code>index</code> by calling
              <code>splice(index, count)</code>.
            </p>
            <p>
              Returns the removed items.
            </p>
          </dd>
          <dt>
            sequence&lt;TimedTemplate&gt; splice ()
          </dt>
          <dd>
            <p>
              Modifies the list of children of this group by first removing
              <code>deleteCount</code> items from <code>start</code> followed by
              adding <code>newItems</code> at the same point.
            </p>
            <p>
              Returns a sequence of the items removed from group during the
              removal step (regardless of whether these items were re-added
              during the addition step).
            </p>
            <p>
              As with <code>AnimationGroup.slice</code> the operation of
              slice is based on <a
              href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf#page=140">ECMAScript
              5's Array.prototype.splice</a>.
            </p>
            <p>
              The operation of this method is identical to that of
              <code>AnimationGroup.slice</code> with the notable difference
              that DOMExceptions of type HierarchyRequestError are not thrown
              since there is no <code>AnimationGroupTemplate</code>
              corresponding to a document timeline.
            </p>
            <dl class="parameters">
              <dt>long start</dt>
              <dd>
                The index at which items should be removed and inserted.
                Negative indices represent an offset from the end of the list of
                items.
                This value is clamped to the range [-<code>length</code>,
                <code>length</code>].
              </dd>
              <dt>unsigned long deleteCount</dt>
              <dd>
                The number of items to remove from the group beginning at
                <code>start</code>.
                Negative values are clamped to zero, and all other values are
                clamped such that
                0 &lt; <code>start</code> + <code>deleteCount</code> &le;
                length.
              </dd>
              <dt>sequence&lt;TimedTemplate&gt; newItems</dt>
              <dd>
                The items to be added at <code>start</code>.
                Each item, if it already has a parent group (including this
                group), is first removed from its parent group before being
                added to this group.
              </dd>
            </dl>
          </dd>
          <dt>
            sequence&lt;TimedTemplate&gt; splice (long start,
              unsigned long deleteCount, TimedTemplate... newItem)
          </dt>
          <dd>
            An overload of <code>splice</code> to take a variadic list of items
            rather than requiring a sequence.
            The operation is identical to <code>splice(unsigned long start,
            unsigned long deleteCount, sequence&lt;TimedTemplate&gt;
            newItems)</code>.
          </dd>
          <dt>long indexOf (TimedTemplate item)</dt>
          <dd>
            Returns the index of <code>item</code> within the group.
            If <code>item</code> is not in the group, returns <code>-1</code>.
          </dd>
        </dl>
      </section>
      <section>
        <h3>The <code>ParGroupTemplate</code> interface</h3>
        <p>
          <a>ParGroup</a> objects can be created from <a>ParGroupTemplate</a>
          objects.
        </p>
        <dl title="[Constructor] interface ParGroupTemplate
          : AnimationGroupTemplate"
          class="idl">
        </dl>
      </section>
      <section>
        <h3>The <code>SeqGroupTemplate</code> interface</h3>
        <p>
          <a>SeqGroup</a> objects can be created from <a>SeqGroupTemplate</a>
          objects.
        </p>
        <dl title="[Constructor] interface SeqGroupTemplate
          : AnimationGroupTemplate" class="idl">
        </dl>
      </section>
      <section>
        <h3>Instantiating an <code>AnimationGroupTemplate</code></h3>
        <p class="todo">
          TBD. This is probably all wrong.
        </p>
        <p>
          The procedure for creating an <code>AnimationGroup</code> from
          an <code>AnimationGroupTemplate</code>, <var>template</var>,
          given a list of target elements, and optionally given a <var>parent
          group</var> follows.
        </p>
        <p>
          Note that <code>ParGroupTemplate</code> objects produce
          <code>ParGroup</code> objects and likewise
          <code>SeqGroupTemplate</code> objects produce <code>SeqGroup</code>
          objects.
          In the following description the <code>AnimationGroupTemplate</code>
          and <code>AnimationGroup</code> types should be substituted with the
          concrete types in use.
        </p>
        <ol>
          <li>
            Create an empty sequence to hold the generated
            <code>AnimationGroup</code> objects.
          </li>
          <li>
            For each <var>element</var> in the list of target elements:
            <ol>
              <li>
                Create a new <code>AnimationGroup</code> object,
                <var>group</var>.
              </li>
              <li>
                Set the <code>timing</code> property of <var>group</var> to
                a copy of <code>template.timing</code>.
              </li>
              <li>
                For each <var>child</var> in <var>template</var>, call
                <code><var>child</var>.animateWithParent(<var>element</var>,
                <var>group</var>, <code>startTime</code>)</code> or
                <code><var>child</var>.animateLiveWithParent(<var>element</var>,
                <var>group</var>, <code>startTime</code>)</code> depending on
                whether this procedure was invoked with <code>animate</code> or
                <code>animateLive</code>.
              </li>
              <li>
                If <var>parentGroup</var> is not specified, let
                <var>parentGroup</var> be
                <code><var>element</var>.ownerDocument.animationTimeline</code>.
              </li>
              <li>
                Append <var>group</var> to <var>parentGroup</var>.
              </li>
              <li>
                Append <var>group</var> to the sequence of
                <code>AnimationGroup</code> objects.
              </li>
            </ol>
          </li>
          <li>
            Return the sequence of <code>AnimationGroup</code> objects.
          </li>
        </ol>
      </section>
    </section>

  </body>
</html>
